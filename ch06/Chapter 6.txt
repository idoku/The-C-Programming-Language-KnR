Chapter 6 Structures
    A structure is a collection of one or more variables,possibly of different types,grouped together under a single name for convenient handling.
    结构是一个或多个变量的集合,这些变量可能属于不同的类型,为了方便处理将它们组织在一个名称下.
(Structures are called "records" in some languages,notably Pascal.) 
(结构也叫做"记录"在一些语言,特别是Pascal语言.)
Structures help to organize complicated data,particulaly in large programs,because they permit a group of related variables to be treated as a unit instead of as separate entities.
由于结构将一组相关变量看作一个单元而不是各自独立的实体,所以通常被用来组织复杂数据,特别是在大型程序中.
    One traditional example of structure is the payroll record:an employee is described by a set of attributes such as name,address,social security number,salary,etc.Some of these in turn could be structures:
    用来描述结构的一个传统例子是工资记录:每个员工由一组属性来描述,像姓名,住址,社保号,工资等.其中一些可以定义为结构类型:
a name has several components,as does an address and even a salary.Another example,more typical for C,somes from graphics:a point is a pair of coordinates,a rectangle is a pair of points,and so on.
姓名可以分成几个组成部分,地址和工资也可能出现相同情况.另一个例子,在C语言中,更加典型的例子来自于图形:点由一对坐标定义,矩形由两个点定义.等等.
    The main change made by the ANSI standard is to define structure assignment - structures may be copied and assigned to,passed to functions,and returned by functions.
    ANSI C标准中的主要变化是定义了对结构的赋值操作 --- 结构可以拷贝,赋值,传递给函数,通过函数返回.
This has been supported by most compiler for many years,but the properties are now precisely defined.Automatic structures and arrays may now also be initialized.
很久以来大多数编译程序就支持这一点,只是其性质进行了更明确的定义.自动结构和数组现在也允许初始化.

6.1 Basic of Structures
    Let us create a few structures suitable for graphics.The basic object is a point,which we will assume has an x coordinate and a y coordinate,both integers.
    让我们创建一些适用于绘图的结构.最基本对象是点,这些点我们假设用x与y坐标表示它,且x,y坐标都取整形.

The two compontes can be placed in a structure declared like this:
两个部分可以在结构中声明像如下:
    struct point{
        int x;
        int y;
    };
    The keyword struct introduce a structure declaration,which is a list of declarations enclosed in braces.An optional name called a structure tag may follow the word struct(as with point here).
    关键字struct引入结构说明,这种说明是一组说明在花括号之内.struct后跟的名字是可选的,它是结构的标记(这里的是point).
The tag names this kind of structure,and can be used subsequently as a shorthand for the part of the declaration in braces.
这个标记用来命名结构,它可以作为花括号内说明的简写.
    The variables named in structure are called members.A structure member or tag and an ordinary(i.e.,non-member) variable can have the same name withou conflict,
    在结构中命名的变量叫做成员.结构成员或者标记和普通变量(就是非成员)能够拥有相同的名字而不会冲突.
since they can always be distinguished by context.
因为它们总是能够通过上下文区分.
Furthermore,the same member names may occur in different structures,although as a matter of style one would normally use the same names only for close related objects.
另外,不同的结构之中的成员可以采用相同的名字,尽管从程序风格上说,通常只有密切关联的对象的才会使用相同的名称.
    A struct declaration defines a type.The right brace that terminated list of members may be followed by a list of variables,just for any basic type.That is
    一个结构声明定义一种类型.在标志结构成员表结束的右括号之后,可以像其他基本类型一样跟随一个变量表.例如,
        struct {...} x,y,z;
is syntactically analogous to 
其语法类似于
        int x,y;
in the sense that each statement declares x,y and z to be variables of named type and cause space to be set aside for them.
其意义就是这两个声明都用于把x,y和z声明为指明类型的变量并且为它们分配存储空间.
    A structure declaration that is not follow by a list of variables reserves to storage;it merely describes a template or the shape of a structure.If the declaration is tagged,however,
    若在结构声明之后没有跟随变量列表,则不需要为之准备存储空间;它仅仅描述了一个结构的模版或者形状.但是如果声明带有标记,那么,
the tag can be used later in definitions of instnce of structure.For example,given the declaration of point above,
那么在以后定义结构实例时可以使用它.例如,对于上面给出的point的声明,
    struct point pt;
defines a variable pt which is a structure of type struct point.A structure can be initialized by following its definition with a list of initializers,each a constant expression,for the members:
定义了一个point结构型的变量pt.结构可以在申明时初始化,方法是在其定义后加上初始化符号表,初始化符号表与各个成员对应的必须是常量表达式:
    struct point maxpt ={ 320,200  }; 
An automatic structure may also be initialized by assignment or by calling a function that returns a structure of the right type.
自动结构也可以通过赋值或调用返回结构类型的函数进行初始化.
   A member of particular structure is referred to in an expression by a construction of the form
   在表达式中可以通过如下形式来引用一特定结构中的成员
        structure-name.member
The structure member operator "." connects the structure name and the member name.To print the coordinates of the point pt,for instance,
结构成员的运算符"."把结构名与成员名连接起来.例如,可以用如下语句打印出点pt的坐标,
        printf("%d%d",pt.x,pt.y);
or compute the distance from the origin(0,0) to pt,
或者用如下代码计算pt与原点(0,0)的距离,
        double dist,sqart(double);
        dist = sqart((double)pt.x*pt.x + (double)pt.y*pt.y);
    Structure can be nested.One representation of a rectangle is a pair of point that denote the diagonally opposite corners:
    结构可以被嵌套.我们可以用对角线上的两个点来定义矩形.其定义如下:

        struct rect {
            struct point pt1;
            struct point pt2;
        }
The rect strucutre contains two point structures.If we declare screen as 
所定义的结构rect包含两个点结构了性.如果我们定义screen为
        struct rect screen;
then
        screen.pt1.x
refers to the x coordinate of the pt1 member of the screen.
访问screen的成员pt1的x坐标值.


6.2 Structures and Functions
    The only legal operations on a structure are copying it or assigning to it as unit,taking it address with &,and accessing its members.
    对结构类型的合法操作只有拷贝,作为单元对其赋值,通过&取地址,和访问其成员这几种.
Copy and assignment include passing arguments to functions and returning values from functions as well.Structures may not be compared.
拷贝和赋值包含传递参数给函数和从函数返回值,结构之间不能比较.
A structure may be initialized by a list of constant member values;an automatic structure may also be initialized by an assignment.
结构能够通过一组成员常量初始化结构;自动结构能够通过赋值来初始化.
    Let us investigate structures by writing some functions to manipluate points and rectangles.There are at least three possible approaches : pass components separately,pass an entire structure,
    为了加强对结构的理解,我们通过编写几个对于点和矩形进行操作的函数.至少有3中可能的方式:一是分别传递各成员,二是传递整个结构;
or pass a point to it.Each has its good points and bad points.
或者传递指针.每一种方法都各有利弊.
    The first function,makepoint,will take two integers and return a point structure:
    第一个函数是makepoint,将需要两个整型并返回一个point结构:
        /* makepoint: make a point from x and y component */
        struct point makepoint(int x,int y)
        {
            struct point temp;
            temp.x = x;
            temp.y = y;
            return temp;
        }
Notice that there is no conflict between the argument name and the member with the same name;indeed the re-use of the names stresses the relationship.
注意,变量名称和成员名称相同不会引起冲突;实际上,重名强调了两者之间的关系.
    makepoint can now be used to initialize any structure dynamically,or to provide structure arguments to a function:
    makepoint现在能够动态初始化任意结构,也可以向函数提供结构类型变量:
        struct rect screen;
        struct point middle;
        struct point makepoint(int,int);
        screen.pt1 = makepoint(0,0);
        screen.pt2 = makepoint(XMAM,YMAX);
        middle = makepoint((screen.pt1.x + screen.pt2.x)/2,
                                      (screen.pt1.y + screen.pt2.y)/2);
    The next step is a set of functions to do arithmetic on points.For instance,
    下面通过一系列的函数对点进行算术运算,例如,
        /* addpoint: add two points */        
        struct point addpoint(struct point p1,struct point p2)
        {
            p1.x += p2.x;
            p1.y += p2.y;
            return p1;
        }
Here both the arguments and the return value are structures.
这里参数和返回值都是结构类型.
We incremented the components in p1 rather than using an explicit temporary variable to emphasize that structure parameters are passed by value like any others.
之所以直接将相加的结果所得结果赋值给p1,而不是使用显示的临时变量,是为了突出结构参数和其他类型参数一样都是按值传递的.
    As another example,the function ptinrect test whether a point is inside a rectangle,where we have adopted the convention that a rectangle includes its left and bottom sides but not its top and right sides:
    另外一个例子,函数ptinrect用于测试是否点在矩形之内,我们采用这样的约定,矩形包括其左边和底边,但不包括它的顶边和右边:
        /* ptinrect: return 1 if p in r,0 if not */
        int ptinrect(struct point p,struct rect r)
        {
            return p.x >= r.pt1.x && p.x <= r.pt2.x 
                && p.y >= r.pt1.y && p.y <= r.pt2.y;
        }
This assumes that the rectangle is represented in a standard form where the pt1 coordinates are less than the pt2 coordinates.The following function returns a rectangle guaranteed to be in canonical form:
这里假设矩形是用标准形式表示的,其中pt1的坐标小于pt2的坐标.下面这个函数返回一个规范形式的矩形:
        #define min(a,b) ((a) < (b) ? (a) : (b))
        #define max(a,b) ((a) > (b) ? (a) :(b))
        /* canonrect : canonicalize coordinates of rectangle */
        struct rect canonrect(struct rect r)
        {
              struct rect temp;
              temp.pt1.x = min(r.pt1.x,r.pt2.x);
              temp.pt1.y = min(r.pt1.y,r.pt2.y);
              temp.pt2.x = max(r.pt1.x,r.pt2.x);
              temp.pt2.y = max(r.pt1.y,r.pt2.y);
        }
    If a large structure is to be passed to a function,it is generally more eifficient to pass a pointer than to copy the whole strucutre.Structure pointers are just like pointers to ordinary variables.The declaration
    如果传递给函数的结构很大,使用指针时效率通常比拷贝结构时高.结构指针类似普通变量的指针.说明语句:
        struct point *pp;
says that pp is a pointer to structure of type struct point.If pp points to a point structure,*pp is the structure,and (*pp).x and (*pp).y are the members.To use pp,we might write,for example,
将pp定义成指向struct point类型的指针.如果pp指向一个point结构,*pp就是该结构,而(*pp).x和(*pp).y就是结构成员.若要使用pp,我们可以写如下语句,例如:
    struct point origin,*pp;
    pp = &origin;
    printf("origin is (%d,%d)\n",(*pp).x,(*pp).y);
The parentheses are neccessary in (*pp).x because the precedence of the structure member operator "." is higher than "*".The expression *pp.x means *(pp.x),which is illegal here because x is not a pointer.
(*pp).x中的圆括号是必须的,因为结构成员运算符.的优先级比*高.表达式*pp.x含义是*(pp.x),因为x不是指针,所以该表达式非法.
    Pointers to structures are so frequently used that an alternative notation is provided as a shorthand.If p is a pointer to a structure,then
    因为结构指针的使用频率很高,于是出现了一种简写方式作为可选的标记法.如果p是结构指针,则
        p->member-of-strucutre
refers to the particuar member.(The operator -> is a minus sign immediately followed by >.) So we could write instead:
引用特定的结构成员.(运算符->是由减号后紧跟>组成的.)因此也可以这样改写:
        printf("original is (%d,%d)\n",pp->x,pp->y);
    Both . and -> associate from left to right,so if we have
    . 和 -> 都是从左到右结合的运算,所以如果有
        struct rect r,*rp = &r;
then these four expressions are equivalent:
那么下面的4个表达式是等价的:
        r.pt1.x
        rp->pt1.x
        (r.pt1).x
        (rp->pt1).x
    The structure operators . and ->,together with () for function calls and [] for subscripts,are at the top of the precedence hierarchy and thus bind very tightly.For example,given the declaration
    结构成员运算符 . 和 -> ,函数调用(),以及下标操作符[]的优先级最高.从而结合最紧密.例如,给定如下声明
        struct{
            int len;
            char *str;
        } *p;
then
        ++p->len
increments len,not p,because the implied parenthesization is ++ (p->len).Parentheses can be used to alter the binding:(++p)->len increments p before accessing len,and (p++)->len icrements p afterward.
增加的是len的值而不是p的值,因为->的优先级比++的高(p->len先执行).括号能够改变绑定次序:(++p)->len先进行p加一操作,在对len操作.而(p++)->len先操作len,再将p加1.
(This last set of parentheses is unnecessary.)
(该表达式中括号可以省略.)
    In the same way,*p->str fetches whatever str points to;*p->str++ increments str after accessing whatever it point to(just like *s++);(*p->str)++ increments whatever str points to;
    同理,*p->str取值是str指向的值;*p->str++先取str的值,再将str加1.(与*s++一样);(*p->str)++将str指向的值加1;
and *p++->str increments p after accessing whatever str points to.
而*p++->str先取str所指向的值,再将p加1.



6.4 Pointer to Structures
    To illustrate some of the considerations involved with pointers to and arrays of structures,let us write the keyword-counting program again,this time using pointers instead of array indices.
    为了说明一些与指向结构数组有关的一些问题讨论,让我们重写keyword-counting程序,这次我们用指针来替代数组下标.
    The external declaration of keytab need not change,but main and binsearch do need modification.
    外部声明的keytab变量不需要改变,但是main函数和binsearch函数需要修改.
#include <stdio.h>
#include <ctype.h>
#include <string.h>

#define MAXWORD 100

int getword(char *,int);
struct key *binsearch(char *,struct key *,int);

/* count C keywords */
main()
{	
	char word[MAXWORD];
	struct key *p;
	
	while(getword(word,MAXWORD)!=EOF)
		if(isalpha(word[0]))
			if((p=binsearch(wrod,keytab,NKEYS))!=NULL)
				p->count++;
	for(p = keytab;p<keytab+NKEYS;p++)
		if(p->count > 0)
			printf("%4d %s\n",p->count,p->word);
	return 0;
}

/* binsearch:find word in tab[0]...tab[n-1] */
struct key *binsearch(char *word,struct key *tab,int n)
{
	int cond;
	struct key *low=&tab[0];
	struct key *high = &tab[n];
	struct key *mid;
	
	while(low<=high)
	{
		mid = low + (high - low)/2;
		if((cond=strcmp(word,mid->word))<0)
			high = mid;
		else if(cond>0)
			low = mid+1;
		else
			return mid;
	}
	return NULL;
}
    There are several things worthy of note here.First,the declaration of binsearch must indicate that it returns a pointer to struct key instead of an integer;
    这里有几个值得注意的地方.首先,binearch返回一个指向struct key指针而不是一个整数;
this is declared both in the function prototype and in binsearch.If binsearch finds the word,it return a pointer to it;if it fails,it returns NULL.
这个函数原型和binsearch中都有声明.如果binsearch找到与输入单词匹配的数组元素,那么返回指向该数组元素的指针,否则返回NULL.
    Second,the elements of keytab are now accessed by pointers,This requires significant changes in binsearch.
    第二点,keytab结构的元素现在都是通过指针来访问,所以需要在binsearch中做较大的修改.
    The initializers for low and high are now pointers to the beginning and just past the end of the table.
    low和high的初始化符现在都是指向表头和表尾后面一个元素的指针.
    The computation of the middle element can no longer be simply
    不能再以简单的表达式计算中间元素的位置
        mid = (low + high) / 2 /* wrong */
because the addition of two pointers is illegal.Subtracction is legal,however,so high - low is the number of elements,and thus
因为对两个指针执行加法运算是非法的.然而指针的减法却是合法的,所以hight - low 的值就是元素的个数.,所以
        mid = low + ( hight - low) / 2
sets mid to point to the element halfway between low and high.
设置mid为指向low和high中间的元素.
    The most important change is to adjust the algorithm to make sure that it does not generate an illegal pointer or attempt to access an element outside the array.
    最主要的改变在于调整了算法使得不会产生非法的指针,以及保证不访问数组范围之外的元素.
The problem is that &tab[-1] and &tab[n] are both outside the limits of the array tab.The former is strictly illegal,and it is illegal to dereference the latter.
问题是&tab[-1]和&tab[n]都是超出了数组tab的范围.前者是绝对非法的,而后者进行对数组的推延也是非法的.
The language definition does guarantee,however,that pointer arithmetic that involves the first element beyond the end of an array(that is,&tab[n]) will work correctly.
然而对数组结束之后的第一个元素的调用(就是&tab[n])的指针运算是可以正常运行的,这可由语言的定义提供保证.
    In main we wrote
    主程序中有这样的语句
        for (p = keytab; p < keytab + NKEYS;p++)
If p is a pointer to a structure,arithmetic on p takes into account the size of the structure,
如果p指针指向一个结构,对p的算术运算要考虑结构的大小,
so p++ increments p by the correct amount to get the next element of the array of structures,and the test stops the loop at the right time.
所以p++在p的基础上加上正确的值,从而得到结构数组的下一个元素,这样使得测试可以保证循环正确结束.
    Don't assume,however,that the size of structure is the sum of the sizes of its members.Becasue of alignment requirements for different objects,there may be unnamed "holes" in a structure.
    然而,千万不要假设结构的大小等于它成员大小之和.因为对不同的对象有不同的对齐要求,所以结构中可能出现无名字的"洞".
Thus,for instance,if a char is one byte and an int four bytes,the structure
例如,对于实例,如果char是占用一个字节而int是占用4个字节,那么结构
        structure{
            char c;
            int i;
        };
might well require eight bytes,not five.The sizeof operator returns the proper value.
则需要8个字节,而不是5个字节.使用sizeof运算返回结构大小正确的值.
    Finally,an aside on program format:when a function returns a complicated type like a structure pointer,as in
    最后一点,关于程序的格式问题:当一个函数返回是复杂类型,像结构指针,比如
        struct key *binsearch(char *word,struct key *tab,int n)
the function name can be hard to see,and to find with a next editor.Accordingly an alternate style is sometimes used:
函数名称不容易一眼就看清楚,也不容易使用文本编辑器查找.上述语句可以通过这样改写:
        struct key *
        binsearch(char *word,struct key *tab,int n)
This is a matter of personal taste;pick the form you like and hold to it.
这纯属个人习惯问题,可以选择自己喜欢的方式并保持自己的风格.