Chapter 6 Structures
    A structure is a collection of one or more variables,possibly of different types,grouped together under a single name for convenient handling.
    结构是一个或多个变量的集合,这些变量可能属于不同的类型,为了方便处理将它们组织在一个名称下.
(Structures are called "records" in some languages,notably Pascal.) 
(结构也叫做"记录"在一些语言,特别是Pascal语言.)
Structures help to organize complicated data,particulaly in large programs,because they permit a group of related variables to be treated as a unit instead of as separate entities.
由于结构将一组相关变量看作一个单元而不是各自独立的实体,所以通常被用来组织复杂数据,特别是在大型程序中.
    One traditional example of structure is the payroll record:an employee is described by a set of attributes such as name,address,social security number,salary,etc.Some of these in turn could be structures:
    用来描述结构的一个传统例子是工资记录:每个员工由一组属性来描述,像姓名,住址,社保号,工资等.其中一些可以定义为结构类型:
a name has several components,as does an address and even a salary.Another example,more typical for C,somes from graphics:a point is a pair of coordinates,a rectangle is a pair of points,and so on.
姓名可以分成几个组成部分,地址和工资也可能出现相同情况.另一个例子,在C语言中,更加典型的例子来自于图形:点由一对坐标定义,矩形由两个点定义.等等.
    The main change made by the ANSI standard is to define structure assignment - structures may be copied and assigned to,passed to functions,and returned by functions.
    ANSI C标准中的主要变化是定义了对结构的赋值操作 --- 结构可以拷贝,赋值,传递给函数,通过函数返回.
This has been supported by most compiler for many years,but the properties are now precisely defined.Automatic structures and arrays may now also be initialized.
很久以来大多数编译程序就支持这一点,只是其性质进行了更明确的定义.自动结构和数组现在也允许初始化.

6.1 Basic of Structures
    Let us create a few structures suitable for graphics.The basic object is a point,which we will assume has an x coordinate and a y coordinate,both integers.
    让我们创建一些适用于绘图的结构.最基本对象是点,这些点我们假设用x与y坐标表示它,且x,y坐标都取整形.

The two compontes can be placed in a structure declared like this:
两个部分可以在结构中声明像如下:
    struct point{
        int x;
        int y;
    };
    The keyword struct introduce a structure declaration,which is a list of declarations enclosed in braces.An optional name called a structure tag may follow the word struct(as with point here).
    关键字struct引入结构说明,这种说明是一组说明在花括号之内.struct后跟的名字是可选的,它是结构的标记(这里的是point).
The tag names this kind of structure,and can be used subsequently as a shorthand for the part of the declaration in braces.
这个标记用来命名结构,它可以作为花括号内说明的简写.
    The variables named in structure are called members.A structure member or tag and an ordinary(i.e.,non-member) variable can have the same name withou conflict,
    在结构中命名的变量叫做成员.结构成员或者标记和普通变量(就是非成员)能够拥有相同的名字而不会冲突.
since they can always be distinguished by context.
因为它们总是能够通过上下文区分.
Furthermore,the same member names may occur in different structures,although as a matter of style one would normally use the same names only for close related objects.
另外,不同的结构之中的成员可以采用相同的名字,尽管从程序风格上说,通常只有密切关联的对象的才会使用相同的名称.
    A struct declaration defines a type.The right brace that terminated list of members may be followed by a list of variables,just for any basic type.That is
    一个结构声明定义一种类型.在标志结构成员表结束的右括号之后,可以像其他基本类型一样跟随一个变量表.例如,
        struct {...} x,y,z;
is syntactically analogous to 
其语法类似于
        int x,y;
in the sense that each statement declares x,y and z to be variables of named type and cause space to be set aside for them.
其意义就是这两个声明都用于把x,y和z声明为指明类型的变量并且为它们分配存储空间.
    A structure declaration that is not follow by a list of variables reserves to storage;it merely describes a template or the shape of a structure.If the declaration is tagged,however,
    若在结构声明之后没有跟随变量列表,则不需要为之准备存储空间;它仅仅描述了一个结构的模版或者形状.但是如果声明带有标记,那么,
the tag can be used later in definitions of instnce of structure.For example,given the declaration of point above,
那么在以后定义结构实例时可以使用它.例如,对于上面给出的point的声明,
    struct point pt;
defines a variable pt which is a structure of type struct point.A structure can be initialized by following its definition with a list of initializers,each a constant expression,for the members:
定义了一个point结构型的变量pt.结构可以在申明时初始化,方法是在其定义后加上初始化符号表,初始化符号表与各个成员对应的必须是常量表达式:
    struct point maxpt ={ 320,200  }; 
An automatic structure may also be initialized by assignment or by calling a function that returns a structure of the right type.
自动结构也可以通过赋值或调用返回结构类型的函数进行初始化.
   A member of particular structure is referred to in an expression by a construction of the form
   在表达式中可以通过如下形式来引用一特定结构中的成员
        structure-name.member
The structure member operator "." connects the structure name and the member name.To print the coordinates of the point pt,for instance,
结构成员的运算符"."把结构名与成员名连接起来.例如,可以用如下语句打印出点pt的坐标,
        printf("%d%d",pt.x,pt.y);
or compute the distance from the origin(0,0) to pt,
或者用如下代码计算pt与原点(0,0)的距离,
        double dist,sqart(double);
        dist = sqart((double)pt.x*pt.x + (double)pt.y*pt.y);
    Structure can be nested.One representation of a rectangle is a pair of point that denote the diagonally opposite corners:
    结构可以被嵌套.我们可以用对角线上的两个点来定义矩形.其定义如下:

        struct rect {
            struct point pt1;
            struct point pt2;
        }
The rect strucutre contains two point structures.If we declare screen as 
所定义的结构rect包含两个点结构了性.如果我们定义screen为
        struct rect screen;
then
        screen.pt1.x
refers to the x coordinate of the pt1 member of the screen.
访问screen的成员pt1的x坐标值.


6.2 Structures and Functions
    The only legal operations on a structure are copying it or assigning to it as unit,taking it address with &,and accessing its members.
    对结构类型的合法操作只有拷贝,作为单元对其赋值,通过&取地址,和访问其成员这几种.
Copy and assignment include passing arguments to functions and returning values from functions as well.Structures may not be compared.
拷贝和赋值包含传递参数给函数和从函数返回值,结构之间不能比较.
A structure may be initialized by a list of constant member values;an automatic structure may also be initialized by an assignment.
结构能够通过一组成员常量初始化结构;自动结构能够通过赋值来初始化.
    Let us investigate structures by writing some functions to manipluate points and rectangles.There are at least three possible approaches : pass components separately,pass an entire structure,
    为了加强对结构的理解,我们通过编写几个对于点和矩形进行操作的函数.至少有3中可能的方式:一是分别传递各成员,二是传递整个结构;
or pass a point to it.Each has its good points and bad points.
或者传递指针.每一种方法都各有利弊.
    The first function,makepoint,will take two integers and return a point structure:
    第一个函数是makepoint,将需要两个整型并返回一个point结构:
        /* makepoint: make a point from x and y component */
        struct point makepoint(int x,int y)
        {
            struct point temp;
            temp.x = x;
            temp.y = y;
            return temp;
        }
Notice that there is no conflict between the argument name and the member with the same name;indeed the re-use of the names stresses the relationship.
注意,变量名称和成员名称相同不会引起冲突;实际上,重名强调了两者之间的关系.
    makepoint can now be used to initialize any structure dynamically,or to provide structure arguments to a function:
    makepoint现在能够动态初始化任意结构,也可以向函数提供结构类型变量:
        struct rect screen;
        struct point middle;
        struct point makepoint(int,int);
        screen.pt1 = makepoint(0,0);
        screen.pt2 = makepoint(XMAM,YMAX);
        middle = makepoint((screen.pt1.x + screen.pt2.x)/2,
                                      (screen.pt1.y + screen.pt2.y)/2);
    The next step is a set of functions to do arithmetic on points.For instance,
    下面通过一系列的函数对点进行算术运算,例如,
        /* addpoint: add two points */        
        struct point addpoint(struct point p1,struct point p2)
        {
            p1.x += p2.x;
            p1.y += p2.y;
            return p1;
        }
Here both the arguments and the return value are structures.
这里参数和返回值都是结构类型.
We incremented the components in p1 rather than using an explicit temporary variable to emphasize that structure parameters are passed by value like any others.
之所以直接将相加的结果所得结果赋值给p1,而不是使用显示的临时变量,是为了突出结构参数和其他类型参数一样都是按值传递的.
    As another example,the function ptinrect test whether a point is inside a rectangle,where we have adopted the convention that a rectangle includes its left and bottom sides but not its top and right sides:
    另外一个例子,函数ptinrect用于测试是否点在矩形之内,我们采用这样的约定,矩形包括其左边和底边,但不包括它的顶边和右边:
        /* ptinrect: return 1 if p in r,0 if not */
        int ptinrect(struct point p,struct rect r)
        {
            return p.x >= r.pt1.x && p.x <= r.pt2.x 
                && p.y >= r.pt1.y && p.y <= r.pt2.y;
        }
This assumes that the rectangle is represented in a standard form where the pt1 coordinates are less than the pt2 coordinates.The following function returns a rectangle guaranteed to be in canonical form:
这里假设矩形是用标准形式表示的,其中pt1的坐标小于pt2的坐标.下面这个函数返回一个规范形式的矩形:
        #define min(a,b) ((a) < (b) ? (a) : (b))
        #define max(a,b) ((a) > (b) ? (a) :(b))
        /* canonrect : canonicalize coordinates of rectangle */
        struct rect canonrect(struct rect r)
        {
              struct rect temp;
              temp.pt1.x = min(r.pt1.x,r.pt2.x);
              temp.pt1.y = min(r.pt1.y,r.pt2.y);
              temp.pt2.x = max(r.pt1.x,r.pt2.x);
              temp.pt2.y = max(r.pt1.y,r.pt2.y);
        }
    If a large structure is to be passed to a function,it is generally more eifficient to pass a pointer than to copy the whole strucutre.Structure pointers are just like pointers to ordinary variables.The declaration
    如果传递给函数的结构很大,使用指针时效率通常比拷贝结构时高.结构指针类似普通变量的指针.说明语句:
        struct point *pp;
says that pp is a pointer to structure of type struct point.If pp points to a point structure,*pp is the structure,and (*pp).x and (*pp).y are the members.To use pp,we might write,for example,
将pp定义成指向struct point类型的指针.如果pp指向一个point结构,*pp就是该结构,而(*pp).x和(*pp).y就是结构成员.若要使用pp,我们可以写如下语句,例如:
    struct point origin,*pp;
    pp = &origin;
    printf("origin is (%d,%d)\n",(*pp).x,(*pp).y);
The parentheses are neccessary in (*pp).x because the precedence of the structure member operator "." is higher than "*".The expression *pp.x means *(pp.x),which is illegal here because x is not a pointer.
(*pp).x中的圆括号是必须的,因为结构成员运算符.的优先级比*高.表达式*pp.x含义是*(pp.x),因为x不是指针,所以该表达式非法.
    Pointers to structures are so frequently used that an alternative notation is provided as a shorthand.If p is a pointer to a structure,then
    因为结构指针的使用频率很高,于是出现了一种简写方式作为可选的标记法.如果p是结构指针,则
        p->member-of-strucutre
refers to the particuar member.(The operator -> is a minus sign immediately followed by >.) So we could write instead:
引用特定的结构成员.(运算符->是由减号后紧跟>组成的.)因此也可以这样改写:
        printf("original is (%d,%d)\n",pp->x,pp->y);
    Both . and -> associate from left to right,so if we have
    . 和 -> 都是从左到右结合的运算,所以如果有
        struct rect r,*rp = &r;
then these four expressions are equivalent:
那么下面的4个表达式是等价的:
        r.pt1.x
        rp->pt1.x
        (r.pt1).x
        (rp->pt1).x
    The structure operators . and ->,together with () for function calls and [] for subscripts,are at the top of the precedence hierarchy and thus bind very tightly.For example,given the declaration
    结构成员运算符 . 和 -> ,函数调用(),以及下标操作符[]的优先级最高.从而结合最紧密.例如,给定如下声明
        struct{
            int len;
            char *str;
        } *p;
then
        ++p->len
increments len,not p,because the implied parenthesization is ++ (p->len).Parentheses can be used to alter the binding:(++p)->len increments p before accessing len,and (p++)->len icrements p afterward.
增加的是len的值而不是p的值,因为->的优先级比++的高(p->len先执行).括号能够改变绑定次序:(++p)->len先进行p加一操作,在对len操作.而(p++)->len先操作len,再将p加1.
(This last set of parentheses is unnecessary.)
(该表达式中括号可以省略.)
    In the same way,*p->str fetches whatever str points to;*p->str++ increments str after accessing whatever it point to(just like *s++);(*p->str)++ increments whatever str points to;
    同理,*p->str取值是str指向的值;*p->str++先取str的值,再将str加1.(与*s++一样);(*p->str)++将str指向的值加1;
and *p++->str increments p after accessing whatever str points to.
而*p++->str先取str所指向的值,再将p加1.



6.4 Pointer to Structures
    To illustrate some of the considerations involved with pointers to and arrays of structures,let us write the keyword-counting program again,this time using pointers instead of array indices.
    为了说明一些与指向结构数组有关的一些问题讨论,让我们重写keyword-counting程序,这次我们用指针来替代数组下标.
    The external declaration of keytab need not change,but main and binsearch do need modification.
    外部声明的keytab变量不需要改变,但是main函数和binsearch函数需要修改.
#include <stdio.h>
#include <ctype.h>
#include <string.h>

#define MAXWORD 100

int getword(char *,int);
struct key *binsearch(char *,struct key *,int);

/* count C keywords */
main()
{	
	char word[MAXWORD];
	struct key *p;
	
	while(getword(word,MAXWORD)!=EOF)
		if(isalpha(word[0]))
			if((p=binsearch(wrod,keytab,NKEYS))!=NULL)
				p->count++;
	for(p = keytab;p<keytab+NKEYS;p++)
		if(p->count > 0)
			printf("%4d %s\n",p->count,p->word);
	return 0;
}

/* binsearch:find word in tab[0]...tab[n-1] */
struct key *binsearch(char *word,struct key *tab,int n)
{
	int cond;
	struct key *low=&tab[0];
	struct key *high = &tab[n];
	struct key *mid;
	
	while(low<=high)
	{
		mid = low + (high - low)/2;
		if((cond=strcmp(word,mid->word))<0)
			high = mid;
		else if(cond>0)
			low = mid+1;
		else
			return mid;
	}
	return NULL;
}
    There are several things worthy of note here.First,the declaration of binsearch must indicate that it returns a pointer to struct key instead of an integer;
    这里有几个值得注意的地方.首先,binearch返回一个指向struct key指针而不是一个整数;
this is declared both in the function prototype and in binsearch.If binsearch finds the word,it return a pointer to it;if it fails,it returns NULL.
这个函数原型和binsearch中都有声明.如果binsearch找到与输入单词匹配的数组元素,那么返回指向该数组元素的指针,否则返回NULL.
    Second,the elements of keytab are now accessed by pointers,This requires significant changes in binsearch.
    第二点,keytab结构的元素现在都是通过指针来访问,所以需要在binsearch中做较大的修改.
    The initializers for low and high are now pointers to the beginning and just past the end of the table.
    low和high的初始化符现在都是指向表头和表尾后面一个元素的指针.
    The computation of the middle element can no longer be simply
    不能再以简单的表达式计算中间元素的位置
        mid = (low + high) / 2 /* wrong */
because the addition of two pointers is illegal.Subtracction is legal,however,so high - low is the number of elements,and thus
因为对两个指针执行加法运算是非法的.然而指针的减法却是合法的,所以hight - low 的值就是元素的个数.,所以
        mid = low + ( hight - low) / 2
sets mid to point to the element halfway between low and high.
设置mid为指向low和high中间的元素.
    The most important change is to adjust the algorithm to make sure that it does not generate an illegal pointer or attempt to access an element outside the array.
    最主要的改变在于调整了算法使得不会产生非法的指针,以及保证不访问数组范围之外的元素.
The problem is that &tab[-1] and &tab[n] are both outside the limits of the array tab.The former is strictly illegal,and it is illegal to dereference the latter.
问题是&tab[-1]和&tab[n]都是超出了数组tab的范围.前者是绝对非法的,而后者进行对数组的推延也是非法的.
The language definition does guarantee,however,that pointer arithmetic that involves the first element beyond the end of an array(that is,&tab[n]) will work correctly.
然而对数组结束之后的第一个元素的调用(就是&tab[n])的指针运算是可以正常运行的,这可由语言的定义提供保证.
    In main we wrote
    主程序中有这样的语句
        for (p = keytab; p < keytab + NKEYS;p++)
If p is a pointer to a structure,arithmetic on p takes into account the size of the structure,
如果p指针指向一个结构,对p的算术运算要考虑结构的大小,
so p++ increments p by the correct amount to get the next element of the array of structures,and the test stops the loop at the right time.
所以p++在p的基础上加上正确的值,从而得到结构数组的下一个元素,这样使得测试可以保证循环正确结束.
    Don't assume,however,that the size of structure is the sum of the sizes of its members.Becasue of alignment requirements for different objects,there may be unnamed "holes" in a structure.
    然而,千万不要假设结构的大小等于它成员大小之和.因为对不同的对象有不同的对齐要求,所以结构中可能出现无名字的"洞".
Thus,for instance,if a char is one byte and an int four bytes,the structure
例如,对于实例,如果char是占用一个字节而int是占用4个字节,那么结构
        structure{
            char c;
            int i;
        };
might well require eight bytes,not five.The sizeof operator returns the proper value.
则需要8个字节,而不是5个字节.使用sizeof运算返回结构大小正确的值.
    Finally,an aside on program format:when a function returns a complicated type like a structure pointer,as in
    最后一点,关于程序的格式问题:当一个函数返回是复杂类型,像结构指针,比如
        struct key *binsearch(char *word,struct key *tab,int n)
the function name can be hard to see,and to find with a next editor.Accordingly an alternate style is sometimes used:
函数名称不容易一眼就看清楚,也不容易使用文本编辑器查找.上述语句可以通过这样改写:
        struct key *
        binsearch(char *word,struct key *tab,int n)
This is a matter of personal taste;pick the form you like and hold to it.
这纯属个人习惯问题,可以选择自己喜欢的方式并保持自己的风格.


6.5 Self-referential Structures
    Suppose we want to handle the more general problem of counting the occurrences of all the words in some input.Since the list of words isn't known in advance,
    假设我们想要处理更一般的问题,即统计所有单词的出现次数.因为预先不知道单词表,
we can't conveniently sort it and use a binary seach.Yet we can't do a linear seach for each word as it arrives,to see if it's already been seen;the program would take too long.
我们不能按通常的方法排序并使用二分查找.也不能对每一个单词做一次线性查找,看它是否存在;若这样的话,程序将执行太长的时间.
(More precisely,its running time is likely to grow quadratically with the number of input words.) How can we organize the data to copy efficiently with a list of arbitrary words?
(更确切的说,它的运行时间随着单词输入的次数而成二次方的增加.)我们怎么能够组织数据来处理任意的单词呢?
    One solution is to keep the set of words seen so far sorted all times,by placing each word into its proper position in the order as it arrives.This shouldn't be done by shifting words in a linear array,
    一个解决方法是:通过将输入单词有序的放入正确的位置.从而在任意时刻都保持已输入单词的有序性.然而这不能通过在线性数组中简单的移动单词来达到目的.
though -- that also takes too long.Instead we will use a data structuure called a binary tree.
尽管可行,因为它显然会导致程序执行的时间过长.作为替代,我们将使用数据结构叫做二叉树.
    The tree contins one "node" per distinct word;each node contains
    每个不同的单词在树中都是一个"node";每一个节点包含
        a pointer to the text of the word
        一个指向单词文本的指针
        a count of the number of occurrences
        一个出现的次数的计数值
        a pointer to the left chid node
        一个指向左子节点的指针
        a pointer to the right child node
        一个指向右子节点的指针
No node may have more than two children;it might have only zero or one.
没有任何节点包含多于两个子节点;当然也可能只包含0个或1个.
    The nodes are maintained so that at any node the left subree contains only words that are lexicographically less than the word at the node,and the right subtree contains only words that are greater.
    节点的组织方法如下:每个节点的左子树包含按字典序小于该节点的那些节点,而右子树只包含按字典序大于该节点的节点.
This is the tree for the sentence "now is the time for all good men to come to the aid of their party",as built by inserting each word as it is encountered:
下面是对句子"now is the time for all good man to come to the aid of their party"中个单词按序插入后构件的树.
    
To find out whether a new word is already in the three,start at the root and compare the new word to the word stored at that node.If they match,the question is answered affirmatively.
为查找一个新的单词是否已经存在树中,可从根节点处开始并且比较这个新的单词与节点的单词是否匹配.如果匹配,则得到肯定的答案.
If the new word is less than the tree word,continue searching at the left child,otherwise at the right child.If there is no child in the required direction,the new word is not in the tree,
如果新的单词小于树上节点的单词,则继续搜索左子树,否则搜索右子树.如果没有子树在搜索方向上,那么新单词不在该树中,
and in fact the empty slot is the proper place to add the new word.This process is recursive,since the search from any node uses a search from one of its children.Accordingly,
事实上这个空槽是正确的位置来添加这个新的单词.因为从任意节点触发的查找使用了它一个子树的查找过程,所以这个过程是递归的.相应的,
recursive routines for insertion and printing will be most natural.
对于插入和打印的操作,使用递归是最自然的.
    Going back to the description of a node,it is conveniently represented as a structure with four components:
    回到节点描述,一个更方便的表示是使用具有一下四个成份的结构
        Struct tnode{        /* the tree node; */
            char *word;      /* points to the text */
            int count;        /* number of occurrences */
            struct tnode *left;     /*  left child  */
            struct tnode *right;    /* right child */
        }
This recursive declaration of a node might look chancy,but it's correct.It is illegal for a structure to contian an instance of itself,but
这个节点的递归定义看上去可能有些危险,但是它是正确的.一个结构包含其自身是非法的,但是
    struct tnode *left;
declares left to be a pointer to a tnode,not a tnode itsefl.
定义了left为指向tnode的指针,而不是tnode本身.
    Occasionally,one needs a variation of self-referential structures:two structures that refer to each other.The way to handle this is:
    偶尔,一种需要自身引用结构的变形:两个结构互相引用对方.这个解决方法如下:
        struct t{
            ...
            struct s *p;   /* p points to an s */
        };
        struct s{
            ...
            struct t *q;    /* q points to a t */
        }
    The code for the the whole program is surprisingly small,given a handful of supporting routines like getword that we have already written.
    代码对整个程序来说惊人的短小,如果给了一些处理过的函数来支持它,像getword我们之前编写过.
The main routine reads words with getword and installs them in the tree with addtree.
main程序通过getword读取单词并且通过addtree函数把它们插入到树中.
#include <stdio.h>
#include <ctype.h>
#include <string.h>

#define MAXWORD 100
struct tnode *addtree(struct tnode *,char *);
void treeprint(struct tnode *);
int getword(char *,int);

/* word frequency count */
main()
{
	struct tnode *root;
	char word[MAXWORD];
	root = NULL;
	while(getword(word,MAXWORD)!=EOF)
		if(isalpha(word[0]))
			root = addtree(root,word);
	treeprint(root);
	return 0;
}
    The function addtree is recursive.A word is presented by main to the top level(the root) of the tree.At each stage,that word is compared to the word already stored at the node,
    函数addtree是递归的.由主程序给出一个单词作为树的最顶层(即树的根).在每一步中,新单词与存在节点中的单词比较,
and is percolated down to either the left or right subtree by a recursive call to addtree.Eventually the word either matches something already in the tree(in which case the count is incremented),
随后通过对addtree的调用而经过左子树或右子树.该单词最终将于树中某节点匹配(在这种情况下计数值1),
or a null pointer is encountered,indicating that a node must be created and added to the tree.If a new node is created,addtree returns a pointer to it,which is installed in the parent node.
或遇上一个空指针,表明必须创建一个节点再加到树中去.如果一个新的节点被创建,addtree返回一个指针指向它,并将该指针存入父节点.
    struct tnode *talloc(void);
    char *strdup(char *);
    
    /* addtree: add a node with w,at or below p */
    struct tnode *addtree(struct tnode *p,char *w)
    {
        int cond;
        if( p == NULL){ /* a new word has arrived */
            p = talloc();  /* make a new node */
            p->word = strdup(w);
            p->count = 1;
            p->left = p->right = NULL;
        }else if((cond = strcmp(w,p->word))==0)
            p->count++; /* repeated word */
        else if(cond < 0) /* less than into subtree */
            p->left  = addtree(p->left,w);
        else  /* greater than into right subtree */
            p->right = addtree(p->right,w);
        return p;
    }
    Storage for the new node is fetched by a routine talloc,which returns a pointer to a free space suitable for holding a tree node,and the new word is copied to a hidden place by strdup.
     新节点的存储区通过调用函数talloc而获得,talloc函数返回一个指针,指向能容纳树节点的自由空间,函数strdup将新的单词拷贝到一个隐藏位置.
(We will discuss these routines in a moment.)The count is initialized,and the two children are made null.This part of the code is executed only at the leaves of the tree,when a new node is being added.
(我们稍后讨论这些函数)计数值被初始化,两个子树也置为空.当增加新节点时,这部分代码在叶子端执行.
We have (unwisely) omitted error checking on the values returned by strdup and talloc.
我们忽略了strdup和talloc的返回值的错误检查.
    treepoint prints the tree in sorted order:at each node,it prints the left subtree(all the words less than this word),then the word itself,then the right subtree(all the words greater).
    treepoint按序打印树;在每个节点,它先打印左子树(所有小于该单词的单词),然后打印单词本身,然后打印右子树(所有大于该单词的单词).
If you feel shaky about how recursion words,simulate treeprint as it operates on the tree shown above.
如果你对递归操作感到怀疑的话,不妨对上述树进行treeprint操作.
        /* treeprint:in-order print of tree p */
        void treeprint(struct tnode *p)
        {
                if(p!=NULL)
                {
                    treeprint(p->left);
                    printf("%4d %s\n",p->count,p->word);
                    treeprint(p->right);
                }
        }
    A practial note:if the tree becomes "unbalanced" because the words don't arrive in random order,the running time of the program can grow too much.As a worst case,if the words area already in order,
有一点值得注意:如果由于单词的输入次序不是随机的次序使得树变得"不平衡",程序的运行时间会大大加长.最坏的情况是,如果单词都是有序输入的,
this program  does an expensive simulation of linear search.There are generalizations of the binary tree that do not suffer from this worst-case behavior,but we will not describe them there.
程序进行会模拟线性查找.有一些广义二叉树,它们不会受到这个最坏情况的影响,但是这里我们不讨论它们.
    Before we leave this example,it is also worth a brief digression on a program related to storage allocators.Clearly it's desirable that there be only one storage allocator in program,
    在我们离开这个例子之前,作为题外话简短讨论下关于存储分配程序的问题.显然,程序中只有一个存储分配程序是可取,
even though it allocates different kinds of objects.But if one allocator is to process requests for,sya,points to chars and points to structure tnodes,two question arise.
尽管它需要分配不同对象.但是如果一个分配程序要处理一些请求,比如说,指向字符指针和指向tnodes结构指针,那么会引发两个问题.
First,How does it meet requirement of most real machines that objects of certain types must satisfy alignment restrictions(for example,integers often must be located at even addresses)?
第一个,它怎么样满足大多数机器的需求,使得特定类型的对象必须满足对齐限制(例如,整数常常必须分配在偶地址上)?
Second,What declarations can cope with the fact that an allocator must necessarily return different kinds of pointers?
第二个,用什么样的说明能够解决这样的问题:分配程序必须返回不同类型的指针?
    Alignment requirements can generally be satisfied easily,at the cost of some wasted space,by ensuring that the allocator alwasys return a pointer that meets all alignment restrictioins.
    对齐需求通常容易被满足,通过确保分配程序总是返回满足所有对齐限制的指针,代价是浪费一些存储空间.
The alloc of Chapter 5 does not guarantee any particular alignment,so we will use the standard library function malloc,which does.In Chapter 8 we will show one way to implement malloc.
第五章介绍的alloc函数不保证任何特殊的对齐,所以我们将使用标准库函数malloc来保证对齐.在第8章,我们将展示一个方法来实现malloc.
    The question of the type declaration for a function like malloc is a vexing one for any language that takes its type-checking seriously.In C,the proper method is to declare that malloc returns a pointer to void,
    对于任何注重检查类型的语言来说,像malloc这样的函数的类型声明问题是非常讨厌的.在C中,一个恰当的方法来定义是让malloc返回一个指向void的指针,
then explicitly coerce the pointer into the desired type with a cast.malloc and related routines are declared in the standard header <stdlib.h>.Thus talloc can be written as 
然后再显示地将指针强制转换为想要的类型.malloc和有关的程序都定义在标准头文件<stdlib.h>中,因此可以将talloc写成如下:
        #include <stdlib.h>
        /* talloc: make a tnode */
        struct tnode *talloc(void)
        {
            return (struct tnode*)malloc(sizeof(struct tnode));
        }
    strdup merely copies the string given by its argument into a safe plcae,obtained by a call on malloc.
    strdup函数只是把由其变量给出的字符串拷贝到一个安全的位置,可以通过调用malloc实现.
        char *strdup(char *s) /* make a duplicate of s */
        {
            char *p;
            p = (char *)malloc(strlen(s)+1); /* +1 for '\0' */
            if(p!=NULL)
                strcopy(p,s);
            return p;
        }
malloc returns NULL if no space is available;strdup passes that value on,leaving error-handling to its caller.
如果没有空间可用时,malloc返回NULL值;strdup函数返回值即是malloc的返回值,且strdup将错误处理留给它的调用者.
    Storage obtained by calling malloc may be freed for re-use by calling free;see Chapter 7 and 8.
    由调用malloc函数而获得的存储区可以通过调用free来释放掉而重用;见第7章和第8章.

Exercise 6-2. Write a program that reads a C Program and prints in alphabetical order each group of variable names that are identical in the first 6 characters,but different somewhere thereafter.Don't count words within strings and comments.Make 6 a parameter that can be set from the command line.

Exercise 6-3. Write a cross-referencer taht prints a list of all words in a doucment,and,for each word,a list of the line numbers on which it occurs.Remove noise words like "the","and",and so on.

Exercise 6-4. Write a program that prints the distinct words in its input sorted into decreasing order of frequency of occurrence.Precede each word by its count.    