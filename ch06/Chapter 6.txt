Chapter 6 Structures
    A structure is a collection of one or more variables,possibly of different types,grouped together under a single name for convenient handling.
    结构是一个或多个变量的集合,这些变量可能属于不同的类型,为了方便处理将它们组织在一个名称下.
(Structures are called "records" in some languages,notably Pascal.) 
(结构也叫做"记录"在一些语言,特别是Pascal语言.)
Structures help to organize complicated data,particulaly in large programs,because they permit a group of related variables to be treated as a unit instead of as separate entities.
由于结构将一组相关变量看作一个单元而不是各自独立的实体,所以通常被用来组织复杂数据,特别是在大型程序中.
    One traditional example of structure is the payroll record:an employee is described by a set of attributes such as name,address,social security number,salary,etc.Some of these in turn could be structures:
    用来描述结构的一个传统例子是工资记录:每个员工由一组属性来描述,像姓名,住址,社保号,工资等.其中一些可以定义为结构类型:
a name has several components,as does an address and even a salary.Another example,more typical for C,somes from graphics:a point is a pair of coordinates,a rectangle is a pair of points,and so on.
姓名可以分成几个组成部分,地址和工资也可能出现相同情况.另一个例子,在C语言中,更加典型的例子来自于图形:点由一对坐标定义,矩形由两个点定义.等等.
    The main change made by the ANSI standard is to define structure assignment - structures may be copied and assigned to,passed to functions,and returned by functions.
    ANSI C标准中的主要变化是定义了对结构的赋值操作 --- 结构可以拷贝,赋值,传递给函数,通过函数返回.
This has been supported by most compiler for many years,but the properties are now precisely defined.Automatic structures and arrays may now also be initialized.
很久以来大多数编译程序就支持这一点,只是其性质进行了更明确的定义.自动结构和数组现在也允许初始化.

6.1 Basic of Structures
    Let us create a few structures suitable for graphics.The basic object is a point,which we will assume has an x coordinate and a y coordinate,both integers.
    让我们创建一些适用于绘图的结构.最基本对象是点,这些点我们假设用x与y坐标表示它,且x,y坐标都取整形.

The two compontes can be placed in a structure declared like this:
两个部分可以在结构中声明像如下:
    struct point{
        int x;
        int y;
    };
    The keyword struct introduce a structure declaration,which is a list of declarations enclosed in braces.An optional name called a structure tag may follow the word struct(as with point here).
    关键字struct引入结构说明,这种说明是一组说明在花括号之内.struct后跟的名字是可选的,它是结构的标记(这里的是point).
The tag names this kind of structure,and can be used subsequently as a shorthand for the part of the declaration in braces.
这个标记用来命名结构,它可以作为花括号内说明的简写.
    The variables named in structure are called members.A structure member or tag and an ordinary(i.e.,non-member) variable can have the same name withou conflict,
    在结构中命名的变量叫做成员.结构成员或者标记和普通变量(就是非成员)能够拥有相同的名字而不会冲突.
since they can always be distinguished by context.
因为它们总是能够通过上下文区分.
Furthermore,the same member names may occur in different structures,although as a matter of style one would normally use the same names only for close related objects.
另外,不同的结构之中的成员可以采用相同的名字,尽管从程序风格上说,通常只有密切关联的对象的才会使用相同的名称.
    A struct declaration defines a type.The right brace that terminated list of members may be followed by a list of variables,just for any basic type.That is
    一个结构声明定义一种类型.在标志结构成员表结束的右括号之后,可以像其他基本类型一样跟随一个变量表.例如,
        struct {...} x,y,z;
is syntactically analogous to 
其语法类似于
        int x,y;
in the sense that each statement declares x,y and z to be variables of named type and cause space to be set aside for them.
其意义就是这两个声明都用于把x,y和z声明为指明类型的变量并且为它们分配存储空间.
    A structure declaration that is not follow by a list of variables reserves to storage;it merely describes a template or the shape of a structure.If the declaration is tagged,however,
    若在结构声明之后没有跟随变量列表,则不需要为之准备存储空间;它仅仅描述了一个结构的模版或者形状.但是如果声明带有标记,那么,
the tag can be used later in definitions of instnce of structure.For example,given the declaration of point above,
那么在以后定义结构实例时可以使用它.例如,对于上面给出的point的声明,
    struct point pt;
defines a variable pt which is a structure of type struct point.A structure can be initialized by following its definition with a list of initializers,each a constant expression,for the members:
定义了一个point结构型的变量pt.结构可以在申明时初始化,方法是在其定义后加上初始化符号表,初始化符号表与各个成员对应的必须是常量表达式:
    struct point maxpt ={ 320,200  }; 
An automatic structure may also be initialized by assignment or by calling a function that returns a structure of the right type.
自动结构也可以通过赋值或调用返回结构类型的函数进行初始化.
   A member of particular structure is referred to in an expression by a construction of the form
   在表达式中可以通过如下形式来引用一特定结构中的成员
        structure-name.member
The structure member operator "." connects the structure name and the member name.To print the coordinates of the point pt,for instance,
结构成员的运算符"."把结构名与成员名连接起来.例如,可以用如下语句打印出点pt的坐标,
        printf("%d%d",pt.x,pt.y);
or compute the distance from the origin(0,0) to pt,
或者用如下代码计算pt与原点(0,0)的距离,
        double dist,sqart(double);
        dist = sqart((double)pt.x*pt.x + (double)pt.y*pt.y);
    Structure can be nested.One representation of a rectangle is a pair of point that denote the diagonally opposite corners:
    结构可以被嵌套.我们可以用对角线上的两个点来定义矩形.其定义如下:

        struct rect {
            struct point pt1;
            struct point pt2;
        }
The rect strucutre contains two point structures.If we declare screen as 
所定义的结构rect包含两个点结构了性.如果我们定义screen为
        struct rect screen;
then
        screen.pt1.x
refers to the x coordinate of the pt1 member of the screen.
访问screen的成员pt1的x坐标值.


6.2 Structures and Functions
    The only legal operations on a structure are copying it or assigning to it as unit,taking it address with &,and accessing its members.
    对结构类型的合法操作只有拷贝,作为单元对其赋值,通过&取地址,和访问其成员这几种.
Copy and assignment include passing arguments to functions and returning values from functions as well.Structures may not be compared.
拷贝和赋值包含传递参数给函数和从函数返回值,结构之间不能比较.
A structure may be initialized by a list of constant member values;an automatic structure may also be initialized by an assignment.
结构能够通过一组成员常量初始化结构;自动结构能够通过赋值来初始化.
    Let us investigate structures by writing some functions to manipluate points and rectangles.There are at least three possible approaches : pass components separately,pass an entire structure,
    为了加强对结构的理解,我们通过编写几个对于点和矩形进行操作的函数.至少有3中可能的方式:一是分别传递各成员,二是传递整个结构;
or pass a point to it.Each has its good points and bad points.
或者传递指针.每一种方法都各有利弊.
    The first function,makepoint,will take two integers and return a point structure:
    第一个函数是makepoint,将需要两个整型并返回一个point结构:
        /* makepoint: make a point from x and y component */
        struct point makepoint(int x,int y)
        {
            struct point temp;
            temp.x = x;
            temp.y = y;
            return temp;
        }
Notice that there is no conflict between the argument name and the member with the same name;indeed the re-use of the names stresses the relationship.
注意,变量名称和成员名称相同不会引起冲突;实际上,重名强调了两者之间的关系.
    makepoint can now be used to initialize any structure dynamically,or to provide structure arguments to a function:
    makepoint现在能够动态初始化任意结构,也可以向函数提供结构类型变量:
        struct rect screen;
        struct point middle;
        struct point makepoint(int,int);
        screen.pt1 = makepoint(0,0);
        screen.pt2 = makepoint(XMAM,YMAX);
        middle = makepoint((screen.pt1.x + screen.pt2.x)/2,
                                      (screen.pt1.y + screen.pt2.y)/2);
    The next step is a set of functions to do arithmetic on points.For instance,
    下面通过一系列的函数对点进行算术运算,例如,
        /* addpoint: add two points */        
        struct point addpoint(struct point p1,struct point p2)
        {
            p1.x += p2.x;
            p1.y += p2.y;
            return p1;
        }
Here both the arguments and the return value are structures.
这里参数和返回值都是结构类型.
We incremented the components in p1 rather than using an explicit temporary variable to emphasize that structure parameters are passed by value like any others.
之所以直接将相加的结果所得结果赋值给p1,而不是使用显示的临时变量,是为了突出结构参数和其他类型参数一样都是按值传递的.
    As another example,the function ptinrect test whether a point is inside a rectangle,where we have adopted the convention that a rectangle includes its left and bottom sides but not its top and right sides:
    另外一个例子,函数ptinrect用于测试是否点在矩形之内,我们采用这样的约定,矩形包括其左边和底边,但不包括它的顶边和右边:
        /* ptinrect: return 1 if p in r,0 if not */
        int ptinrect(struct point p,struct rect r)
        {
            return p.x >= r.pt1.x && p.x <= r.pt2.x 
                && p.y >= r.pt1.y && p.y <= r.pt2.y;
        }
This assumes that the rectangle is represented in a standard form where the pt1 coordinates are less than the pt2 coordinates.The following function returns a rectangle guaranteed to be in canonical form:
这里假设矩形是用标准形式表示的,其中pt1的坐标小于pt2的坐标.下面这个函数返回一个规范形式的矩形:
        #define min(a,b) ((a) < (b) ? (a) : (b))
        #define max(a,b) ((a) > (b) ? (a) :(b))
        /* canonrect : canonicalize coordinates of rectangle */
        struct rect canonrect(struct rect r)
        {
              struct rect temp;
              temp.pt1.x = min(r.pt1.x,r.pt2.x);
              temp.pt1.y = min(r.pt1.y,r.pt2.y);
              temp.pt2.x = max(r.pt1.x,r.pt2.x);
              temp.pt2.y = max(r.pt1.y,r.pt2.y);
        }
    If a large structure is to be passed to a function,it is generally more eifficient to pass a pointer than to copy the whole strucutre.Structure pointers are just like pointers to ordinary variables.The declaration
    如果传递给函数的结构很大,使用指针时效率通常比拷贝结构时高.结构指针类似普通变量的指针.说明语句:
        struct point *pp;
says that pp is a pointer to structure of type struct point.If pp points to a point structure,*pp is the structure,and (*pp).x and (*pp).y are the members.To use pp,we might write,for example,
将pp定义成指向struct point类型的指针.如果pp指向一个point结构,*pp就是该结构,而(*pp).x和(*pp).y就是结构成员.若要使用pp,我们可以写如下语句,例如:
    struct point origin,*pp;
    pp = &origin;
    printf("origin is (%d,%d)\n",(*pp).x,(*pp).y);
The parentheses are neccessary in (*pp).x because the precedence of the structure member operator "." is higher than "*".The expression *pp.x means *(pp.x),which is illegal here because x is not a pointer.
(*pp).x中的圆括号是必须的,因为结构成员运算符.的优先级比*高.表达式*pp.x含义是*(pp.x),因为x不是指针,所以该表达式非法.
    Pointers to structures are so frequently used that an alternative notation is provided as a shorthand.If p is a pointer to a structure,then
    因为结构指针的使用频率很高,于是出现了一种简写方式作为可选的标记法.如果p是结构指针,则
        p->member-of-strucutre
refers to the particuar member.(The operator -> is a minus sign immediately followed by >.) So we could write instead:
引用特定的结构成员.(运算符->是由减号后紧跟>组成的.)因此也可以这样改写:
        printf("original is (%d,%d)\n",pp->x,pp->y);
    Both . and -> associate from left to right,so if we have
    . 和 -> 都是从左到右结合的运算,所以如果有
        struct rect r,*rp = &r;
then these four expressions are equivalent:
那么下面的4个表达式是等价的:
        r.pt1.x
        rp->pt1.x
        (r.pt1).x
        (rp->pt1).x
    The structure operators . and ->,together with () for function calls and [] for subscripts,are at the top of the precedence hierarchy and thus bind very tightly.For example,given the declaration
    结构成员运算符 . 和 -> ,函数调用(),以及下标操作符[]的优先级最高.从而结合最紧密.例如,给定如下声明
        struct{
            int len;
            char *str;
        } *p;
then
        ++p->len
increments len,not p,because the implied parenthesization is ++ (p->len).Parentheses can be used to alter the binding:(++p)->len increments p before accessing len,and (p++)->len icrements p afterward.
增加的是len的值而不是p的值,因为->的优先级比++的高(p->len先执行).括号能够改变绑定次序:(++p)->len先进行p加一操作,在对len操作.而(p++)->len先操作len,再将p加1.
(This last set of parentheses is unnecessary.)
(该表达式中括号可以省略.)
    In the same way,*p->str fetches whatever str points to;*p->str++ increments str after accessing whatever it point to(just like *s++);(*p->str)++ increments whatever str points to;
    同理,*p->str取值是str指向的值;*p->str++先取str的值,再将str加1.(与*s++一样);(*p->str)++将str指向的值加1;
and *p++->str increments p after accessing whatever str points to.
而*p++->str先取str所指向的值,再将p加1.



6.4 Pointer to Structures
    To illustrate some of the considerations involved with pointers to and arrays of structures,let us write the keyword-counting program again,this time using pointers instead of array indices.
    为了说明一些与指向结构数组有关的一些问题讨论,让我们重写keyword-counting程序,这次我们用指针来替代数组下标.
    The external declaration of keytab need not change,but main and binsearch do need modification.
    外部声明的keytab变量不需要改变,但是main函数和binsearch函数需要修改.
#include <stdio.h>
#include <ctype.h>
#include <string.h>

#define MAXWORD 100

int getword(char *,int);
struct key *binsearch(char *,struct key *,int);

/* count C keywords */
main()
{	
	char word[MAXWORD];
	struct key *p;
	
	while(getword(word,MAXWORD)!=EOF)
		if(isalpha(word[0]))
			if((p=binsearch(wrod,keytab,NKEYS))!=NULL)
				p->count++;
	for(p = keytab;p<keytab+NKEYS;p++)
		if(p->count > 0)
			printf("%4d %s\n",p->count,p->word);
	return 0;
}

/* binsearch:find word in tab[0]...tab[n-1] */
struct key *binsearch(char *word,struct key *tab,int n)
{
	int cond;
	struct key *low=&tab[0];
	struct key *high = &tab[n];
	struct key *mid;
	
	while(low<=high)
	{
		mid = low + (high - low)/2;
		if((cond=strcmp(word,mid->word))<0)
			high = mid;
		else if(cond>0)
			low = mid+1;
		else
			return mid;
	}
	return NULL;
}
    There are several things worthy of note here.First,the declaration of binsearch must indicate that it returns a pointer to struct key instead of an integer;
    这里有几个值得注意的地方.首先,binearch返回一个指向struct key指针而不是一个整数;
this is declared both in the function prototype and in binsearch.If binsearch finds the word,it return a pointer to it;if it fails,it returns NULL.
这个函数原型和binsearch中都有声明.如果binsearch找到与输入单词匹配的数组元素,那么返回指向该数组元素的指针,否则返回NULL.
    Second,the elements of keytab are now accessed by pointers,This requires significant changes in binsearch.
    第二点,keytab结构的元素现在都是通过指针来访问,所以需要在binsearch中做较大的修改.
    The initializers for low and high are now pointers to the beginning and just past the end of the table.
    low和high的初始化符现在都是指向表头和表尾后面一个元素的指针.
    The computation of the middle element can no longer be simply
    不能再以简单的表达式计算中间元素的位置
        mid = (low + high) / 2 /* wrong */
because the addition of two pointers is illegal.Subtracction is legal,however,so high - low is the number of elements,and thus
因为对两个指针执行加法运算是非法的.然而指针的减法却是合法的,所以hight - low 的值就是元素的个数.,所以
        mid = low + ( hight - low) / 2
sets mid to point to the element halfway between low and high.
设置mid为指向low和high中间的元素.
    The most important change is to adjust the algorithm to make sure that it does not generate an illegal pointer or attempt to access an element outside the array.
    最主要的改变在于调整了算法使得不会产生非法的指针,以及保证不访问数组范围之外的元素.
The problem is that &tab[-1] and &tab[n] are both outside the limits of the array tab.The former is strictly illegal,and it is illegal to dereference the latter.
问题是&tab[-1]和&tab[n]都是超出了数组tab的范围.前者是绝对非法的,而后者进行对数组的推延也是非法的.
The language definition does guarantee,however,that pointer arithmetic that involves the first element beyond the end of an array(that is,&tab[n]) will work correctly.
然而对数组结束之后的第一个元素的调用(就是&tab[n])的指针运算是可以正常运行的,这可由语言的定义提供保证.
    In main we wrote
    主程序中有这样的语句
        for (p = keytab; p < keytab + NKEYS;p++)
If p is a pointer to a structure,arithmetic on p takes into account the size of the structure,
如果p指针指向一个结构,对p的算术运算要考虑结构的大小,
so p++ increments p by the correct amount to get the next element of the array of structures,and the test stops the loop at the right time.
所以p++在p的基础上加上正确的值,从而得到结构数组的下一个元素,这样使得测试可以保证循环正确结束.
    Don't assume,however,that the size of structure is the sum of the sizes of its members.Becasue of alignment requirements for different objects,there may be unnamed "holes" in a structure.
    然而,千万不要假设结构的大小等于它成员大小之和.因为对不同的对象有不同的对齐要求,所以结构中可能出现无名字的"洞".
Thus,for instance,if a char is one byte and an int four bytes,the structure
例如,对于实例,如果char是占用一个字节而int是占用4个字节,那么结构
        structure{
            char c;
            int i;
        };
might well require eight bytes,not five.The sizeof operator returns the proper value.
则需要8个字节,而不是5个字节.使用sizeof运算返回结构大小正确的值.
    Finally,an aside on program format:when a function returns a complicated type like a structure pointer,as in
    最后一点,关于程序的格式问题:当一个函数返回是复杂类型,像结构指针,比如
        struct key *binsearch(char *word,struct key *tab,int n)
the function name can be hard to see,and to find with a next editor.Accordingly an alternate style is sometimes used:
函数名称不容易一眼就看清楚,也不容易使用文本编辑器查找.上述语句可以通过这样改写:
        struct key *
        binsearch(char *word,struct key *tab,int n)
This is a matter of personal taste;pick the form you like and hold to it.
这纯属个人习惯问题,可以选择自己喜欢的方式并保持自己的风格.


6.5 Self-referential Structures
    Suppose we want to handle the more general problem of counting the occurrences of all the words in some input.Since the list of words isn't known in advance,
    假设我们想要处理更一般的问题,即统计所有单词的出现次数.因为预先不知道单词表,
we can't conveniently sort it and use a binary seach.Yet we can't do a linear seach for each word as it arrives,to see if it's already been seen;the program would take too long.
我们不能按通常的方法排序并使用二分查找.也不能对每一个单词做一次线性查找,看它是否存在;若这样的话,程序将执行太长的时间.
(More precisely,its running time is likely to grow quadratically with the number of input words.) How can we organize the data to copy efficiently with a list of arbitrary words?
(更确切的说,它的运行时间随着单词输入的次数而成二次方的增加.)我们怎么能够组织数据来处理任意的单词呢?
    One solution is to keep the set of words seen so far sorted all times,by placing each word into its proper position in the order as it arrives.This shouldn't be done by shifting words in a linear array,
    一个解决方法是:通过将输入单词有序的放入正确的位置.从而在任意时刻都保持已输入单词的有序性.然而这不能通过在线性数组中简单的移动单词来达到目的.
though -- that also takes too long.Instead we will use a data structuure called a binary tree.
尽管可行,因为它显然会导致程序执行的时间过长.作为替代,我们将使用数据结构叫做二叉树.
    The tree contins one "node" per distinct word;each node contains
    每个不同的单词在树中都是一个"node";每一个节点包含
        a pointer to the text of the word
        一个指向单词文本的指针
        a count of the number of occurrences
        一个出现的次数的计数值
        a pointer to the left chid node
        一个指向左子节点的指针
        a pointer to the right child node
        一个指向右子节点的指针
No node may have more than two children;it might have only zero or one.
没有任何节点包含多于两个子节点;当然也可能只包含0个或1个.
    The nodes are maintained so that at any node the left subree contains only words that are lexicographically less than the word at the node,and the right subtree contains only words that are greater.
    节点的组织方法如下:每个节点的左子树包含按字典序小于该节点的那些节点,而右子树只包含按字典序大于该节点的节点.
This is the tree for the sentence "now is the time for all good men to come to the aid of their party",as built by inserting each word as it is encountered:
下面是对句子"now is the time for all good man to come to the aid of their party"中个单词按序插入后构件的树.
    
To find out whether a new word is already in the three,start at the root and compare the new word to the word stored at that node.If they match,the question is answered affirmatively.
为查找一个新的单词是否已经存在树中,可从根节点处开始并且比较这个新的单词与节点的单词是否匹配.如果匹配,则得到肯定的答案.
If the new word is less than the tree word,continue searching at the left child,otherwise at the right child.If there is no child in the required direction,the new word is not in the tree,
如果新的单词小于树上节点的单词,则继续搜索左子树,否则搜索右子树.如果没有子树在搜索方向上,那么新单词不在该树中,
and in fact the empty slot is the proper place to add the new word.This process is recursive,since the search from any node uses a search from one of its children.Accordingly,
事实上这个空槽是正确的位置来添加这个新的单词.因为从任意节点触发的查找使用了它一个子树的查找过程,所以这个过程是递归的.相应的,
recursive routines for insertion and printing will be most natural.
对于插入和打印的操作,使用递归是最自然的.
    Going back to the description of a node,it is conveniently represented as a structure with four components:
    回到节点描述,一个更方便的表示是使用具有一下四个成份的结构
        Struct tnode{        /* the tree node; */
            char *word;      /* points to the text */
            int count;        /* number of occurrences */
            struct tnode *left;     /*  left child  */
            struct tnode *right;    /* right child */
        }
This recursive declaration of a node might look chancy,but it's correct.It is illegal for a structure to contian an instance of itself,but
这个节点的递归定义看上去可能有些危险,但是它是正确的.一个结构包含其自身是非法的,但是
    struct tnode *left;
declares left to be a pointer to a tnode,not a tnode itsefl.
定义了left为指向tnode的指针,而不是tnode本身.
    Occasionally,one needs a variation of self-referential structures:two structures that refer to each other.The way to handle this is:
    偶尔,一种需要自身引用结构的变形:两个结构互相引用对方.这个解决方法如下:
        struct t{
            ...
            struct s *p;   /* p points to an s */
        };
        struct s{
            ...
            struct t *q;    /* q points to a t */
        }
    The code for the the whole program is surprisingly small,given a handful of supporting routines like getword that we have already written.
    代码对整个程序来说惊人的短小,如果给了一些处理过的函数来支持它,像getword我们之前编写过.
The main routine reads words with getword and installs them in the tree with addtree.
main程序通过getword读取单词并且通过addtree函数把它们插入到树中.
#include <stdio.h>
#include <ctype.h>
#include <string.h>

#define MAXWORD 100
struct tnode *addtree(struct tnode *,char *);
void treeprint(struct tnode *);
int getword(char *,int);

/* word frequency count */
main()
{
	struct tnode *root;
	char word[MAXWORD];
	root = NULL;
	while(getword(word,MAXWORD)!=EOF)
		if(isalpha(word[0]))
			root = addtree(root,word);
	treeprint(root);
	return 0;
}
    The function addtree is recursive.A word is presented by main to the top level(the root) of the tree.At each stage,that word is compared to the word already stored at the node,
    函数addtree是递归的.由主程序给出一个单词作为树的最顶层(即树的根).在每一步中,新单词与存在节点中的单词比较,
and is percolated down to either the left or right subtree by a recursive call to addtree.Eventually the word either matches something already in the tree(in which case the count is incremented),
随后通过对addtree的调用而经过左子树或右子树.该单词最终将于树中某节点匹配(在这种情况下计数值1),
or a null pointer is encountered,indicating that a node must be created and added to the tree.If a new node is created,addtree returns a pointer to it,which is installed in the parent node.
或遇上一个空指针,表明必须创建一个节点再加到树中去.如果一个新的节点被创建,addtree返回一个指针指向它,并将该指针存入父节点.
    struct tnode *talloc(void);
    char *strdup(char *);
    
    /* addtree: add a node with w,at or below p */
    struct tnode *addtree(struct tnode *p,char *w)
    {
        int cond;
        if( p == NULL){ /* a new word has arrived */
            p = talloc();  /* make a new node */
            p->word = strdup(w);
            p->count = 1;
            p->left = p->right = NULL;
        }else if((cond = strcmp(w,p->word))==0)
            p->count++; /* repeated word */
        else if(cond < 0) /* less than into subtree */
            p->left  = addtree(p->left,w);
        else  /* greater than into right subtree */
            p->right = addtree(p->right,w);
        return p;
    }
    Storage for the new node is fetched by a routine talloc,which returns a pointer to a free space suitable for holding a tree node,and the new word is copied to a hidden place by strdup.
     新节点的存储区通过调用函数talloc而获得,talloc函数返回一个指针,指向能容纳树节点的自由空间,函数strdup将新的单词拷贝到一个隐藏位置.
(We will discuss these routines in a moment.)The count is initialized,and the two children are made null.This part of the code is executed only at the leaves of the tree,when a new node is being added.
(我们稍后讨论这些函数)计数值被初始化,两个子树也置为空.当增加新节点时,这部分代码在叶子端执行.
We have (unwisely) omitted error checking on the values returned by strdup and talloc.
我们忽略了strdup和talloc的返回值的错误检查.
    treepoint prints the tree in sorted order:at each node,it prints the left subtree(all the words less than this word),then the word itself,then the right subtree(all the words greater).
    treepoint按序打印树;在每个节点,它先打印左子树(所有小于该单词的单词),然后打印单词本身,然后打印右子树(所有大于该单词的单词).
If you feel shaky about how recursion words,simulate treeprint as it operates on the tree shown above.
如果你对递归操作感到怀疑的话,不妨对上述树进行treeprint操作.
        /* treeprint:in-order print of tree p */
        void treeprint(struct tnode *p)
        {
                if(p!=NULL)
                {
                    treeprint(p->left);
                    printf("%4d %s\n",p->count,p->word);
                    treeprint(p->right);
                }
        }
    A practial note:if the tree becomes "unbalanced" because the words don't arrive in random order,the running time of the program can grow too much.As a worst case,if the words area already in order,
有一点值得注意:如果由于单词的输入次序不是随机的次序使得树变得"不平衡",程序的运行时间会大大加长.最坏的情况是,如果单词都是有序输入的,
this program  does an expensive simulation of linear search.There are generalizations of the binary tree that do not suffer from this worst-case behavior,but we will not describe them there.
程序进行会模拟线性查找.有一些广义二叉树,它们不会受到这个最坏情况的影响,但是这里我们不讨论它们.
    Before we leave this example,it is also worth a brief digression on a program related to storage allocators.Clearly it's desirable that there be only one storage allocator in program,
    在我们离开这个例子之前,作为题外话简短讨论下关于存储分配程序的问题.显然,程序中只有一个存储分配程序是可取,
even though it allocates different kinds of objects.But if one allocator is to process requests for,sya,points to chars and points to structure tnodes,two question arise.
尽管它需要分配不同对象.但是如果一个分配程序要处理一些请求,比如说,指向字符指针和指向tnodes结构指针,那么会引发两个问题.
First,How does it meet requirement of most real machines that objects of certain types must satisfy alignment restrictions(for example,integers often must be located at even addresses)?
第一个,它怎么样满足大多数机器的需求,使得特定类型的对象必须满足对齐限制(例如,整数常常必须分配在偶地址上)?
Second,What declarations can cope with the fact that an allocator must necessarily return different kinds of pointers?
第二个,用什么样的说明能够解决这样的问题:分配程序必须返回不同类型的指针?
    Alignment requirements can generally be satisfied easily,at the cost of some wasted space,by ensuring that the allocator alwasys return a pointer that meets all alignment restrictioins.
    对齐需求通常容易被满足,通过确保分配程序总是返回满足所有对齐限制的指针,代价是浪费一些存储空间.
The alloc of Chapter 5 does not guarantee any particular alignment,so we will use the standard library function malloc,which does.In Chapter 8 we will show one way to implement malloc.
第五章介绍的alloc函数不保证任何特殊的对齐,所以我们将使用标准库函数malloc来保证对齐.在第8章,我们将展示一个方法来实现malloc.
    The question of the type declaration for a function like malloc is a vexing one for any language that takes its type-checking seriously.In C,the proper method is to declare that malloc returns a pointer to void,
    对于任何注重检查类型的语言来说,像malloc这样的函数的类型声明问题是非常讨厌的.在C中,一个恰当的方法来定义是让malloc返回一个指向void的指针,
then explicitly coerce the pointer into the desired type with a cast.malloc and related routines are declared in the standard header <stdlib.h>.Thus talloc can be written as 
然后再显示地将指针强制转换为想要的类型.malloc和有关的程序都定义在标准头文件<stdlib.h>中,因此可以将talloc写成如下:
        #include <stdlib.h>
        /* talloc: make a tnode */
        struct tnode *talloc(void)
        {
            return (struct tnode*)malloc(sizeof(struct tnode));
        }
    strdup merely copies the string given by its argument into a safe plcae,obtained by a call on malloc.
    strdup函数只是把由其变量给出的字符串拷贝到一个安全的位置,可以通过调用malloc实现.
        char *strdup(char *s) /* make a duplicate of s */
        {
            char *p;
            p = (char *)malloc(strlen(s)+1); /* +1 for '\0' */
            if(p!=NULL)
                strcopy(p,s);
            return p;
        }
malloc returns NULL if no space is available;strdup passes that value on,leaving error-handling to its caller.
如果没有空间可用时,malloc返回NULL值;strdup函数返回值即是malloc的返回值,且strdup将错误处理留给它的调用者.
    Storage obtained by calling malloc may be freed for re-use by calling free;see Chapter 7 and 8.
    由调用malloc函数而获得的存储区可以通过调用free来释放掉而重用;见第7章和第8章.

Exercise 6-2. Write a program that reads a C Program and prints in alphabetical order each group of variable names that are identical in the first 6 characters,but different somewhere thereafter.Don't count words within strings and comments.Make 6 a parameter that can be set from the command line.

Exercise 6-3. Write a cross-referencer taht prints a list of all words in a doucment,and,for each word,a list of the line numbers on which it occurs.Remove noise words like "the","and",and so on.

Exercise 6-4. Write a program that prints the distinct words in its input sorted into decreasing order of frequency of occurrence.Precede each word by its count.    


6.6 Table Lookup
    In this section we will write the innards of a table-lookup package,to illustrate more aspects of structures.
    为了对结构方面做更深入的讨论,本节将编写一个查找表程序包的内部结构.
This code is typical of what might be found in the symbol table management routines of a macro processor or a compiler.For example,consider the #define statement.When a line like
这个代码很经典,可以在宏处理或编译程序的符号表管理程序中找到.例如,考虑#define语句.当遇上如如下行
        #define IN 1
is encountered,the name IN and the replacement text 1 are stored in a table.Later,when the name IN appears in a statement like
时,名字IN和替换文本1都要存储在表中.稍后,当名字IN出现在语句时,像
        state = IN;
it must be replaced by 1.
将用1来替换IN.
    There are two routines that manipulate the names and replacement texts.install(s,t) records the name s and the replacement text t in a table;s and t are just character strings.
    下面有两个程序来操作名字和替换文本.install(s,t)记录名字s和替换文本t在表中;s和t都是字符串.
Lookup(s) searches for s in the table,and returns a pointer to the place where it was found,or NULL if it wasn't there.
Lookup(s)函数查找s在table中,若在某处找到了s,返回一个指向被找到位置的指针,如果没有找到,返回NULL.
    The algorithm is a hash search - the incoming name is converted into a small non-negative integer,which is then used to index into an array of pointers.
    算法采用的是hash查找-将输入的名字转换为一个小的非负整数,这个整数随后被用来当作指针数组的下标.
An array element points to the beginning of a linked list of blocks describing names that have that hash value.It is NULL if no names have hashed to that value.
一个数组元素指向链表块的开始处来描述具有某些散列值的名字.当没有与散列对应的名字时,那么值为NULL.
    
    A block in the list is a structure containing pointers to the name,the replacement text,and the next block in the list.A null next-pointer marks the end of the list.
    链表中的每一个块都是一个结构,它含指向名字的指针,指向替换文本的指针,及指向该链表中后继块的指针.null后继指针标记表尾.
        struct nlist{ /* table entry: */
            struct nlist *next; /* next entry in chain */
            char *name; /* defined name  */
            char *defn; /* replacement text */
        }
The pointer array is just
指针数组仅仅是
        #define HASHSIZE 101
        static struct nlist *hashtab[HASHSIZE]; /* pointer table */
    The hashing function,which is used by both lookup and install,adds each charcter value in the string to a scrambled comination of the previous ones and returns the remainder modulo the array size.
    lookup和install函数中的散列函数,用于将字符串中每个字符值与前面已求得的部分值杂混相加,并返回对数组大小求模后的余数.
This is not the best posible hash function,but it is short and effective.
这个不是最好的散列函数,但是非常简短有效.
        /* hash: form hash value for string s */
        unsigned hash(char *s)
        {
            unsigned hashval;
            for(hashval = 0;*s != '\0' ; s++)
                hashval = *s + 31 * hashval;
            return hashval % HASHSIZE;
        }
unsigned arithmetic ensures that the hash value is non-negative.
无符号运算保证了散列值不为空.
    The hashing process produces a starting index in the array hashtab;if the string is to be found anywhere,it will be in the list of blocks beginning there.The search is performed by lookup.
    散列过程生成了数组hashtab中的一个起始下标;如果要给串与某个起始下标匹配,它将会链表块开始处.具体查找过程由lookup实现.
If lookup finds the entry already present,it returns a pointer to it;if not,it returns NULL.
如果lookup函数发现表项已存在,它将会返回一个指针指向;如果没有,它将会返回NULL.
    /* lookup: look up s in hashtab */
   struct nlist *lookup(char *s)
   {
        struct nlist *np;
        for(np = hashtab[hash(s)];np != NULL; np = np->next)
            if(strcmp(s,np->name)==0)
                return np; /* found */
        return NULL;   /* not found */
    }
The for lookup is the standard idiom for walking along a linked list:
for循环在lookup中是一个标准方法用于遍历整个链表:
        for(ptr = head; ptr != NULL; ptr = ptr->next)
            ...
    install uses lookup to determine whether the name being installed is already present;if so,the new definition will supersede the old one.Otherwise,a new entry is created.
    install函数使用lookup来判断散列名字是否已经存在;如果存在,那么新的定义覆盖老的那个.否则,新的项被创建.
install returns NULL if for any reason there is no room for a new entry.
如果没有足够的空间可以用来新建链表项,install返回NULL.
        struct nlist *lookup(char *);
        char *strdup(char *);
        /* install: put(name,defn) in hashtab */
        struct nlist *install(char *name,char *defn)
        {
            struct nlist *np;
            unsigned hashval;
            if((np=lookup(name)==NULL) { /* not found */
                np = (struct nlist *)malloc(sizeof(*np));
                if( np == NULL || (np->name = strdup(name))==NULL)
                    return NULL;
                hashval = hash(name);
                np->next = hashtab[hashval];
                hashtab[hashval] = np;
            }else{ /* already there */
                free((void*)np->defn); /* free previous defn */
            }
            if((np->defn = strdup(defn))==NULL)
                return NULL;
            return np;
        }


Exercise 6-5. Write a function undef that will remove a name and definition from the table maintained by lookup and install.

Exercise 6-6.Implement a simple version of the #define processor(i.e.,no arguments) suitable for use with C programs,based on the routines of this section.You may also find getch and ungetch helpful.


6.7 Typedef
    C provides a facility called typedef for creating new data type names,For example,the declaration
    C语言提供了叫做typedef的功能来创建新的数据类型名称,例如,定义如下
        typedef int Length;
makes the name Length a synonym for int.The type Length can be used in declarations,casts,etc.,in exactly the same ways that the type int can be:
使得名称Length成为int的同义词.类型Length能够被用来声明,转换等.和类型int完全一样:
        Length len,maxlen;
        Length *lengths[];
Similarly,the declaration
同样的,定义
        typedef char * String;
makes String a synonym for char * or character pointer,which may then be used in declarations and casts:
使得String成为char*或者字符指针的同义词,这样string能够被用来声明和类型转换:
        String p,lineptr[MAXLINES],alloc(int);
        int strcmp(String,String);
        p = (String)malloc(100);
    Notice that the type being declared in a typedef appears in the position of a variable name,not right after the word typedef.Syntactically,typedef is like the storage classes extern,static,etc.
    注意typedef中说明的类型在变量名称的位置出现,而不是接着单词typedef后出现.typedef在语法上类似于存储类extern,static等.
We have used capitalized names for typedefs,to make them stand out.
由typedef说明的类型以大写开头,用来做区别.
    As a more complicated example,we could make typedefs for the tree nodes show earlier in this chapter:
    作为一个更 复杂的例子,我们使用typedefs来重新定义树节点在之前的章节中:
        typedef struct tnode *Treeptr;
        typedef struct tnode{ /* the tree node: */
            char *word; /* points to the text */
            int count;  /* number of occurrences */
            Treeptr left;  /* left child */
            Treeptr right; /* right child */
        } Treenode
This creats two new type keywords called Treenode(a structre) and Treeptr(a pointer to the structure).Then the routine talloc could become
上面创建了两个类型关键词叫做Treenode和Treeptr.那么程序talloc将变成
        Treeptr talloc(void){
            return (Treeptr)malloc(sizeof(Treenode));
        }
    It must be emphasized that a typedef declaration does not create a new type in any sense;it merely adds a new name for some exsiting type.Nor are there any new semantics:
    必须强调typedef定义不会创建新的类型在任何意义上;它仅仅增加一个新的名字给一些存在的类型,typedef也没有新的语义内容:
varibles declared this way have exactly the same properties as variables whose declarations are spelled out explicitly.In effect,typedef is like #define,except that since it is interpreted by the compiler,
变量定义与显示定义的变量属性完全相同.事实上,typedef也类似于#define语句,只有一点不同:由于可被编译程序解释,
it can cope with textual substitutions that are beyond the capabilities of the preprocessor.For example,
它能够处理文本替换.例如,
        typedef int (*PFI)(char *,char *);
creates the type PFI,for "pointer to function (of two char * arguments) returning int," which can be used in contexts like
创建类型PFI,表示"指向函数(只有两个char *参数)返回int类型的函数指针.这可被用于某些场合像,
        PFI strcmp,numcmp;
in the sort program of Chapter 5.
在第五章的排序程序.
    Besides purely aesthetic issues,there are two main reasons for using typedefs.The first is to parameterize a program against portability problems.
    除了看上去简洁美观,使用typedefs还有两个主要的原因.第一个原因是参数化程序,提高程序的可移植性.
If typedefs are used for data types that may be machine-dependent,only typedefs need change when the program is moved.One common situation is to use typedef names for various integer quantities,
如果typedefs使用的数据类型是依赖于机器的,当程序移植到其它机器时,只需要改变typedef类型的定义.一个常见的情况是使用typedef给不同的整形变量声明,
then make an approprite set of choices of short,int,and long for each host machine.Types like size_t and ptrdiff_t from the standard library are examples.
随后为每个宿主机器上选择适当的short,int和long型整数集.例如在标准库中的一些类型,像size_t和ptrdiff_t.
    The second purpose of typedefs is to provide better documentation for a program - a type called Treeptr may be easier to understand than one declared only as a pointer to a complicated structure.
    第二个原因是typedef提供了更好的文档化 --- 一个叫做Treeptr的类型显然比一个说明为指向结构的指针更容易理解.


6.8 Unions
    A union is a variable that may hold (at different times) objects of different types and sizes,with the compiler keeping track of size and alignment requirements.
    联合是一个变量,这个变量能够保存(不同时刻)不同类型和大小的对象,由编译程序负责跟踪分配大小和对齐需求.
Unions provide a way to manipulate different kinds of data in a single area of storage,without embedding any machine-dependent information in the program.
联合提供一种方法,可以在单块存储中来操作不同类型的数据,而不需要在程序中嵌入任何机器依赖的信息.
They are analogous to variant records in Pascal.
它类似于Pascal中的变量记录.
    As an example such as might be found in a compiler symbol table manager,suppose that a constant may be an int,a float,or a character pointer.
    作为一个列子,可以在编译程序的符号表管理程序中找到该例子,假设一个常量可能是int,float,character pointer.
The value of a particular constant must be stored in a variable of the proper type,
一个特定常量的值必须存储在一个相应类型的变量中,
yet it is most convenient for table management if the value occupies the same amount of storage and is stored in the same plcae regardless of its type.
然而表管理最方便的做法是让该值占有相同大小的存储区,而且忽视其类型而存入同一地方.
This is  purpose of a union - a single variable that can legitimately hold any one of several types.The syntax is based on structures:
这就是联合的目的 - 一个简单的变量能够合法的存储任何几种类型中的任意一个.语法基于结构:
        union u_tag{
            int ival;
            float fval;
            char *sval;
        } u;
    The variable u will be large enough to hod the largest of the three types;the specific size is implementation-dependent.Any one of these types may be assigned to u and then used in expressions,
    变量u足够大以便能保存这三种类型中最大的一个,具体大小依赖于实现.在三个类型中的任何一个能够赋值给u并且在表达式中使用,
so long as the usage is consistent:the type retrieved must be type most recently stored.It is the programmer's responsibility to keep track of which type is currently stored in a union;
只要该使用满足一致性:类型取回必须是最后一次存储的类型.跟踪当前存储的联合类型是程序员的职责
the results are implementation-dependent if something is stored as one type and extracted as another.
如果存入类型和提取类型不同,则结果取决于实现.
    Syntactically,members of a union are accessed as
    按照语法,联合中的成员可访问如下
        union-name.member
or 
        union-pointer->member
just as for sturctures.If the variable utype is used to keep track of the current type stored in u,then one might see code such as
和结构一样的访问.如果变量utype被用来跟踪在u中当前类型的存储,可以使用西面的代码来
        if(utype == INT)
            printf("%d\n",u.ival);
        else if(utype == FLOAT)
            printf("%f\n",u.fval);
        else if(utype == STRING)
            printf("%s\n",u.sval);
        else
            printf("bad type %d in utype \n",utype);
    Unions may occur within structures and arrays,and vice versa.The notation for accessing a member of a union in a structure(or vice versa) is identical to that for nested strutures.
    联合可能在结构和数组中出现,反之也可.访问结构中联合(或反之)的某一个成员的表示方法与嵌套结构的方法一样.
For example,in the structure array defined by
例如,在结构数组中定义如下
        strut
        {
            char *name;
            int flags;
            int utype;
            union
            {
                int ival;
                float fval;
                char *sval;
            } u;
        } symtab[NSYM];
the member ival is referred to as
成员ival的引用为:
        symtab[i].v.ival;
and the first character of the string sval by either of
而字符串sval的首字符表示为如下两者之一
        *symtab[i].u.sval;
         symtab[i].u.sval[0];
    In effect,a union is a structure in which all members have offset zero from the base,the structure is big enough to hold the "widest" member,
    事实上,联合就是结构,其所有成员相对于基地址的偏移量为0,这个结构足够大来保存"最宽"的成员,
and the alignment is appropriate for all of the types in the union.The same operations are permitted on unions as on structures:assignment to or copying as a unit,
并且对齐适合于联合中所有成员.对联合的运算与对结构的运算相同:赋值或者拷贝整个联合,
taking the address,and accessing a member.
取地址以及访问成员.
    A union may only be initialized with a value of the type of its first member,thus the union u described above can only be initialized with an integer value.
    一个联合只能用它第一个成员的类型来初始化,从而上述的联合u只能用整形值来初始化.
    The storage allocator in Chapter 8 shows how a union can be used to force a variable to be aligned on a particular kind of storage boundary.
    在第8章的存储分配程序将说明特定类型的存储边界上如何使用联合来强制一个变量的对齐.


6.9 Bit-fields
    When storage space is at a premium,it may be necessary to pack several objects into a single machine word;one common use is a set of single-bit flags in applications like compiler symbol tables.
    当存储空间非常珍贵时,有必要将几个对象打包到一个单一机器字中去;一个常用的方法是使用类似于编译器符号表的单个位标识集合.
Externally-imposed data formats,such as interfaces to hardware devices,also often require the ability to get at pieces of a word.
外部增加数据格式,像硬件设备接口,也常需要能够读取字中的部分位的数据.
    Imagine a fragment of a compiler that manipulates a symbol table.Each identifier in a program has certain information associated with it,for example,whether or not it is a keyword,
    想象编译器操作符号表的那部分.程序中的每一个标志都有与其关联的特定信息,例如,它是否为关键字,
whether or not it is external and/or staitc,and so on.The most compact way to encode such information is a set of one-bit flags in a single char or int.
是否是外部的且(或)静态的,等等.编码这些信息最简洁的方式是使用在单个字符或整数空间内的单个位标志集合.
    The usual way this is done is to define a set of "masks" corresponding to the relevant bit positions,as in
    通常采用的方法是定义一些"masks"集来关联位的位置,例如
        #define KEYWORD 01
        #define EXTERNAL 02
        #define STATIC      04
or 
        enum { KEYWORD = 01,EXTERNAL =02, STATIC = 04 };
The numbers must be powers of two.Then accessing the bits becomes a matter of "bit-fiddling" with the shifting,masking,and complementing operators that were described in Chapter 2.
这些数字必须是2的倍数.然后访问位这些位变成了一个通过shifting,masking及第二章所描述的按位取反运算符的"简单位"操作:
    Certain idioms appear frequently:
    惯用法出现频率很高:
        flags |= EXTERNAL | STATIC;
turns on the EXTERNAL and STATIC bits in flags,while
打开EXTERNAL和STATIC位在flags,而
        flags &= ~(EXTERNAL | STATIC);
turns them off,and 
关闭他们,和
        if((flags & (EXTERNAL | STATIC))==0) ...
is true if both bits are off.
如果位都是关闭的,那结果为true.
    Althouth these idioms are readily mastered,as an alternative C offers the capability of defining and accessing fields within a word directly rather than by bitwise logical operators.
    尽管这些惯用法很容易掌握,作为可选择的C还提供了另一种方法来定义和访问位,即提供在字内直接定义和访问字段的能力,而不是使用按位与逻辑运算.
A bit-field,or field for short,is a set of adjacent bits within a single implementation-defined storage unit that we will call a "word." The syntax of field definition and access is based on structures.
位字段,或者简称为字段,是字中相邻位的集合,所谓字是由实现定义的单一存储单元.字段的定义和访问语法结构上基于结构,
For example,the symbol table #defines above could be replaced by the definition of three fields:
例如,符号table #defines 语句可以用3个字段来代替定义:
    struct{
        unsigned int is_keyword : 1;
        unsigned int is_extern :1;
        unsigned int is_static : 1;
    } flags;
This defines a variable called flags that contains three 1-bit fields.The number following the colon represents the field width in bits.
这种定义变量叫做标志,其包含了3个1位字段.冒号后的数字标识字段的域宽.
The fields are declared unsigned int to ensure that they are unsigned quantities.
这段声明无符号整形来保证它们是无符号量.
    Individual fields are referenced in the same way as other structure members:flags.is_keyword,flags.is_extern,etc.Fields behave like small integers,
    单一字段的引用方式与结构成员相同的,如:flags.is_keyword,flags.is_extern等等.字段的特征与小数整数相似,
and may participate in arithmetic expressions just like other integers.Thus the previous examples may be written more naturally as
与其他整数一样,字段可出现在算术表达式中.所以之前的列子可以编写得更自然一些,
        flags.is_extern = flags.is_static = 1;
to turn the bits on;
位打开:
        flags.is_extern = flags.is_static = 0;
to turn them off; and
位关闭,并且
        if(flags.is_extern == 0 && flags.is_static == 0)
            ...
to test tem.
用于对is_extern和is_static进行测试.
    Almost everything about fields is implementation-dependent.Whether a field may overlap a word boundary is implementation-defined.
    有关字段的所有属性都取决于实现.一个字段是否能覆盖字边界由定义实现.
Fields need not be named;unnamed fields(a colon and width only) are used for padding.The special width 0 may be used to force alignment at the next word boundary.
字段可以无名;无名字段(只有冒号和域宽)被用于填充.特殊的域宽0用于强制在下一个字边界对齐.
    Fields are assigned left to right on some machines and right to left on others.This means that although fields are useful for maintaining internally-defined data structures,
    在一些机器上字段的分配从字左端到右端,而在另一些机器上则相反.这意味着尽管字段对维护内部定义的数据结构很有用,
the question of which end comes first has to be carefully considered when picking apart externally-defined data;programs that depend on such things are not portable.Fields may be declared only as ints;
但当另外选择外部定义的数据时,必须仔细考虑哪端优先的问题,所以依赖这些情况的程序是不可移植的.字段也可能只说明成整形,
for portability,specify signed or unsigned explicitly.They are not arrays,and they do not have addresses,so the & operator cannot be applied to them.
为了方便移植,需显式说明该整形是singed还是unsigned.它们不是数组,并且没有地址,因此对它们不能作用&运算符操作.
