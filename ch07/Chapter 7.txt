CHAPTER 7 Input and Output
    Input and output facilities are not part of the C language iteslf,so we have not emphasized them in our presentation thus far.Nonetheless,
    输入和输出功能并不是C语言本身的组成部分,所以到目前为止,我们并没有过多的强调它们.然而,
parograms interact with thier environment in much more complicated ways than whose we have shown before.In this chapter we will describe the standard libary,
程序与其环境之间的交互与我们之前所展示的相比复杂了许多.本章我们将描述标准库,
a set of functions that provide input and output,string handling,storage management,mathematical routines,and a variety of other services for C programs.We will concentrate on input and output.
一些函数,提供输入,输出和字符串处理,存储管理,数学函数,和一些其他的功能用于C程序.我们将着重讨论输入和输出.
    The ANSI standard defines these library functions precisely,so that they can exist in compatible form on any system where C exists.
    标准的ANSI定义了这些库函数,所以这些函数在任何使用C语言的系统中都能以相容的形式存在.
Programs that confine their system interactions to facilities provided by the standard library can be moved from one system to another without change.
程序系统交互部分仅仅使用了由标准库提供的功能,那么在系统移植到另一个系统时,不需要修改.
    The properties of library functions are specified in more than a dozen headers;we have already seen several of these,including <stdio.h>,<stirng.h>,and <ctype.h>.
    标准库函数的性质分别定义在十几个头文件中;我们之前已经碰到一些,它们是,<stdio.h>,<string.h>和<ctype.h>.
We will not present the entire library here,since we are more interested in writing C programs that use it.The library is described in detail in Appendix B.
我们不会罗列整个标准库在这里,我们更感兴趣是编写C程序来使用它们.附录B对标准库做了详细的描述.

7.1 Standard Input and Output
    As we said in Chapter 1,the library implements a simple model of text input newline character.A text stream consists of a sequence of lines;each line ends with a newline character.
    正如第一章所述,标准库实现了简单的文本输入输出模式.文本流由一些行组成,每一行的结尾是一个换行符.
If the system doesn't operate that way,the library does whatever is necessary to make it appear as if it does.For instance,
如果系统不是这种方式操作,标准库尽可能使该系统适用这种模式.例如,
the library might convert carriage return and linefeed to newline on input and back again on output.
标准库可以在输入端将回车和换行符都转换为换行符,而在输出端反向转换.
    The simplest input mechanism is to read one character at a time from the standard input,normally the keyboard,with getchar:
    最简单的输入机制是读取一个字符每次从标准输入,一般为键盘,通过getchar函数:
        int getchar(void)
getchar returns the next input character each time it is called,or EOF when it encounters end of file.The symbolic constant EOF is defined in <stido.h>.The value is typically -1,
getchar在每次被调用时返回下一个字符,或者EOF当统计到文件末尾.符号常量EOF被定义在<stdio.h>.其值一般为-1.
but tests should be written in terms of EOF so as to be independent of the specific value.
但是程序中应该使用EOF而不是-1来测试文件是否结束,以使得程序独立于EOF的特定值.
    In many environments,a file may be substituted for the keyboard by using the < convention for input redirection:if a program prog uses getchar,then the command line 
    在许多环境中,通过使用符号<让一个文件代替键盘来实现输入重定向:如果程序prog中要使用函数getchar,那么命令行
        prog < infile
causes prog to read characters from infile instead.The swithcing of the input is done in such a way that prog itself is oblivious to the change;in particular,
使得程序prog从文件而不是从键盘中读取字符.实际上,输入开关的实现对程序prog本身是透明的,
the string "< infile" is not included in argv.Input switching is also invsible if the input comes from another program vai a pipe mechanism:on some systems,the command line
字符串"<inflie"也没有包含在argv的命令变量中.如果输入通过管道机制来自另一个程序,那么这种输入开关也是不可见的:在一些系统中,命令行
        otherprog | prog
runs the two programs otherprog and prog,and pipes the standard output of otherprog into the standard input for prog.
将运行两个程序otherprog和prog,而且将程序otherprog的标准输出流连接到程序prog的标准流上.
    The function
        int putchar(int)
is used for output:putchar(c) puts the character c on the standard output,which is by default the screen.putchar returns the character writeen,or EOF if an error occurs.Again,
用于输出:putchar(c)输出字符c在标准输出上,这个标准输出默认是屏幕显示.如果没有错误,putchar返回所有字符,如果出现错误则返回EOF.同理,
output can usually be directed to a file with > filename;if prog uses putchar.
output能够使用>文件名直接重定向输出到某个文件;如果prog使用putchar输出文件.
    prog > outfile
will write the standard output to outfile instead.If pipes are supported,
将输出标准输出的数据到文件outfile中.如果管道被系统支持,那么命令行
    prog | anotherprog
puts the standard output of prog into the standard input of antoherprog.
将程序prog的标准输出流连接到程序anotherprog的标准输出上.
    Output produced by printf also finds its way to the standard output,Calls to putchar and printf may be interleaved - output appears in the order in which the calls were made.
    函数printf也能够用于向标准输出流输出数据,我们在程序中有可能要交叉调用putchar和printf - 输出将按照函数调用的先后次序产生.
    Each source file that refers to an input/output library function must contain the line
    每一个使用输入/输出标准库函数的源程序文件必须在引用这些函数之前包含如下语句
        #include <stdio.h>
before the first reference.When the name is bracketed by < and > a search is made for the header in a stnadard set of places(for example,on UNXI systems,typically in the directory /user/include).
当文件名用一对尖括号<和>括起来时,预处理程序在实现定义的有关位置中查找所指明的文件(例如,在UNXI系统中,通常是在目录/user/include中).
    Many programs read only one input stream and write only one output stream;for such program,input and ouput with getchar,putchar,and printf may be entirely adequate,
    许多程序只从一个输入流读取数据并且仅仅写入一个输出流输出数据;对于这些程序,输入和输出值只需要getchar,putchar和printf来实现输出即可,
and is certainly enough to get started.This is particularly true if redirection is used to connect the output of one program to the input of the next.For example,consider the program lower,
并且能够保证正常启动.尤其是在重定向将一个程序的输出给另一个程序输入的情况下.例如,考虑下面的程序lower,
which converts its input to lower case:
这个程序转换输入的小写字母的形式:
    #include <stdio.h>
    #include <ctype.h>
    main() /* lower:convert input to lower case */
    {
        int c;
        while((c=getchar())!=EOF)
            putchar(tolower(c));
        return 0;
    }
    The function tolower is defined in <ctype.h>;it converts an upper case letter to lower case,and returns other characters untouched.As we mentioned earlier,
    函数tolower定义在<ctype.h>中;它转换一个大写字母为小写形式,并且原样返回其他字符.在我们之前提到的,
"functions" like getchar and putchar in <stdio.h> and tolower in <ctype.h> are often macros,thus avoiding the overhead of a function call per character.
诸如头文件<stdio.h>中的getchar和putchar函数以及<ctype.h>中的tolower"函数"一般都为宏,从而避免了对每个字符都进行函数调用的开销.
We will show how this is done in Secton 8.5.Regardless of how the <ctype.h> functions are implemented on a given machine,programs that use them are shielded from knowledge of the character set.
我们将在8.5节介绍其实现方法.无论<ctype.h>中的函数在给定的机器上是如何实现的,使用这些程序都可以不必了解字符集的知识.

Exercise 7-1.Write a program that converts upper case to lower or lower case to upper,depending on the name it is invoked with,as found in argv[0[.



7.2 Formatted Output - Printf
    The output function printf translates internal values to character.We have used printf informally in previous chapters.The description here convers most typical uses but is not complete;
    输出函数printf用于将内部数值转换为字符.在前面的章节中,我们已经非正式的使用过printf函数.下面的描述包含了最常用的典型用法,但是不是全部的;
for the full story,see Appendix B.
在附录B中给出了完整的使用方法.
        int printf(char *format,arg1,arg2,...)
printf converts,formats,and prints its arguments on the standard output under control of the format.It returns the number of characters printed.
printf函数在输出格式format的控制下,将其参数转换,格式化并在标准输出设备上打印出来.它的返回值为打印的字符数.
    The format string contains two types of object:ordinary characters,which are copied to the output stream,
    格式化字符串包含两个类型的对象:普通字符,将其值拷贝到输出流中.
and conversion specifications,each of which causes conversion and printing of the next successive argument to printf.
和转换规格说明,转换规格说明不拷贝到输出流中,每个说明控制printf中参数的转换和打印
Each conversion specification begins with a % and ends with a conversion character.Between the % and the conversion character there may be,in order:
每一个转换说明都由%引入,并且以一个转换字符结束.在%和转换字符之间可能有如下成分:
A minus sign,which specifies left adjustment of the converted argument.(负号,指定转换参数按照左对齐的形式输出.)
A number that specifies the minimum field width.The converted argument will be printed in a field at least this wide.If necessary it will be padded on the left(or right,if left adjustment is called for) to make up the field width.(数,指定最小字宽.被转换的参数将在不小于最小字段宽的宽度中打印出来.如果必要,字段左面(或右面,如果使用左对齐)多余的字符位置用空格填充以保证最小字段宽)
A period,which separates the field width from the precision.(小数点,用于将字段宽和精度分开.)
A number,the precision,that specifies the maximum number of characters to be printed from a string,or the number of digits after the decimal point of a floating point value,or the minimum number of digits for an integer.(数,精度,指定一个字符所要打印的最大字符数,或者一个浮点数小数点的位置,或一个整数最少输出的数字数目.)
An h if the integer is to be printed as a short,or l (letter ell) if as a long.(字母h或l,字母h表示将整数按short类型打印,字母l表示将整数作为long类型打印.)
Conversion characters are show in Table 7-1.If the character after the % is not a conversion specification,the behavior is underfined.
表7-1列出了所有转换字符.如果%后面的字符不是一个转换规格说明字符,则该行为是未定义的.
Table 7-1.BASIC PRINTF CONVERSIONS


A width or precision may be specified as *,in which case the value is computed by converting the next argument(which must be an int).For example,to print at most max characters from a string s,
在转换规格说明中,一个宽度或者精度可能用*代替,这时,宽度和精度的值通过转换下一个变量（必须为int型)来计算.例如,为了从字符串s中最多打印max个字符,
        printf("%.*s",max,s);
    Most of the format conversions have been illustrated in earlier chapters.One exception is precsion as it relates to strings.
    在前面的章节描述了大多数的格式化转换.但还未介绍与字符串相关的精度.
The following table shows the effect of a variety of specifications in printing "hello,wold"(12 characters).We have put colons around each field so you can see its extent.
下面的表中展示了打印字符串"hello,world"(12个字符),我们在每个字段的两边加上冒号,这样能更清楚的看到宽度.
:%s:             :hello, world:
:%10s:         :hello, world:
:%.10s:        :hello, wor:
:%-10s:        :hello, world:
:%.15s:        :hello, world:
:%-15s:        :hello, world     :
:%15.10s:     :     hello, wor:
:%-15.10s:    :hello, wor     :
A warning:printf uses its first argument to decide how many arguments follow and what their types are.
注意:printf使用它的第一个参数来判断还有多少参数和它们的类型是什么.
It will get confused,and you will get wrong answers,if there are not enough arguments or if they are the wrong type.You should also be aware of the difference between these two calls:
如果printf从第二个参数起的参数少于第一个参数中指定的个数或它们的类型与第一个参数中指定的类型不同时,那么会得到错误的记过.请注意下面两个调用之间的不同:
        printf(s);        /* FAILS if a contains % */
        printf("%s",s) /* SAFE */
    The function sprintf does the same conversions as printf does,but stores the output in a string:
    函数sprinitf做同样的转换和printf所做一样,但是它把输出存在一个字符串中.
        int sprintf(char *string,char *format,arg1,arg2,...)
sprintf formats the arguments in arg1,arg2,etc.,according to format as before,but places the result in string instead of on the standard output;string must be big enougth to recevice the result.
sprintf函数和之前printf函数一样,按照fortmat格式化参数序列,如arg1,arg2,等.但是它将结果存放在string而不是放在标准输出中;当然string必须足够大来接收结果.

Exercise 7-2. Write a program that will print arbitrary input in a sensible way.As a minimum,it shoud print non-graphic characters in octal or hexadecimal according to local custom,and break long text lines.


7.3 Variable-length Argument Lists
    This section contains an implementation of a minimal version of printf,to show how to write a function that processes a variable-length argument list in a portable way.
    本节包含一个简单版本的printf,来演示怎样编写一个处理可变长度的参数的函数.
Since we are mainly interested in the argument processing,minprintf will process the format string and arguments but will call the real printf to do the format cnoversions.
因为重点在参数的处理,minprintf将处理格式化字符串和参数表,格式化转换则通过调用函数printf来实现.
    The proper declaration for printf is 
    下面是printf的正确声明方式
        int printf(char *fmt,..)
where the declaration ... means that the number and types of these arguments may vary.The declaration ... can only appear at the end of an argument list.Our minprintf is declared as
其中,省略号声明...代表参数表中参数的数量和类型可能会变化.省略号声明...只能出现在参数表的结尾处.我们的minprintf声明如下:
        void minprintf(char *fmt,...) 
since we will not return the character count that printf does.
因为我们的minprintf不像printf那样返回实际输出的字符数.
    The tricky bit is how minprintf walks along the argument list when the list doesn't even have a name.
    编写minprintf的关键点在与怎么样处理甚至连名字都没有的变量列表.
This standard header <stdarg.h> contains a set of macro definitions that define how to step through an argument list.
这个标准头文件在<stdarg.h>中包含一组如何处理变量表的宏定义.
The implementation of this header will vary from machine to machine,but the interface it presents is uniform.
这个头文件的实现随着机器不同而不同,但是它所提供的接口是统一的.
    The type va_list is used to declare a variable that will refer to each argument in turn;in minprintf,this variable is called ap,for "argument pointer." 
    类型va_list用来声明一个依次引用每个变量的变量,在minprintf,这个变量叫做ap,表示"argument pointer."
The macro va_start initializes ap to point to the first unnamed argument.It must be called once before ap is used.There must be at least one named argument;
而宏va_start初始化ap指针指向第一个无名变量.在ap使用之前,这个宏必须被调用一次.变量表中必须有至少一个命令变量;
the final named argument is used by va_start to get started.
va_start根据最后一个命名变量的值来对ap进行初始化.
    Each call of va_arg returns one argument and steps ap to the next;va_arg uses a type name to determine what type to return and how big a step to take.
    每一次调用va_arg返回一个变量并且使ap指向下一个变量;va_arg使用一个类型名决定其返回哪种类型的对象及如何使ap指向下一个变量.
Finally,va_end does whatever cleanup is neccessary.It must be called before the function returns.
最终,va_end必须在函数返回之前被调用,完成一些必要的清除工作.
    There properties from the basis of our simplified printf:
    上面是一些属性,我们简单的printf的基础讨论:
#include <stdarg.h>

/* minprintf:minial printf with variable argument list */
void minprintf(char *fmt,...)
{
	va_list ap;/* points to each unnamed arg in turn */
	char *p,*sval;
	int ival;
	double dval;
	va_start(ap,fmt); /* make ap point to 1st unnamed arg */
	for(p = fmt;*p;p++)
	{
		if(*p!='%'){
			putchar(*p);
			continue;
		}
		switch(*++p)
		{
			case 'd':
				ival = va_arg(ap,int);
				printf("%d",ival);
				break;
			case 'f':
				dval = va_arg(ap,double);
				printf("%f",dval);
				break;
			case 's':
				for(sval=va_arg(ap,char *);*sval;sval++)
				{
					putchar(*sval);
				}
				break;
			default:
				putchar(*p);
				break;
		}
	}
	va_end(ap); /* clean up when done */
}

Exercise 7-3. Revise minprintf to handle more of the other facilities of printf.



7.4 Formatted Input - Scanf
    The fnction scanf is the input analog of printf,providing many of the same conversion facilities in the opposite direction.
    输入函数scanf对应于输出函数printf,它在与后者反向上提供同样多的转换功能.
        int scanf(char *format,...)
scanf reads characters from the standard input,interprets them according to the specification in format,and stores the results through the remaining arguments.
scanf函数从标准的输入中读取字符,按照format中的转换规格说明对字符序列进行解释,并把结果存储在其余的变量中.
The format argument is described below;the other arguments,each of which must be a pointer,indicate where the corresponding converted input should be stored.
下面将讨论格式化变量format;其他变量必须是一个指针,用于指明相对应的转换后的输入应该存放的位置.
As with printf,this section is a summary of the most useful features,not an exhaustive list.
像printf一样,本节介绍大多数有用的特性,但不是全部的功能列表.
    scanf stops when it exhausts its format string,or when some input fails to match the control specification.It returns as its value the number of success items were found.
    当scanf函数使用完了格式输入串或当一些输入无法与控制说明相匹配时,它就停止运行.并返回成功匹配和赋值的输入项的个数.
This can be used to decide how many items were found.On end of file,EOF is returned;note that this is different from 0,
所以返回值可以作为判断已获得输入值的输入项的依据.在文件末尾,EOF被返回;注意这与返回值0不同.
which means that the next input character does not match the first specification in the format string.The next call to scanf resumes searching immediately after the last character alredy converted.
0意味着下一个输入字符没有匹配第一个说明符.下一次对这个函数的调用将从上一次成功转换的最后一个字符的下一个字符开始继续搜索.
    There is also a function sscanf that reads from a string instead of the standard input:
    另外一个输入函数sscanf,用于从一个字符串而不是标准输入流中读取字符序列:
        int sscanf(char *string,char *format,arg1,arg2,...)
It scans the string according to the format in format,and stores the resulting values through arg1,arg2,etc.These arguments must be pointers.
它按照格式变量format中说明的格式从字符串string中读取字符序列,并且把结果存储在arg1,arg2等这些变量中.这些参数必须是指针.
    The format string usually contains conversion specifications,which are used to control conversion of input.The format string may contain:
    格式化字符串通常包含转换规格说明,其用来控制输入转换.格式化字符串通常包含:
Blanks or tabs,which are ignored.(空格或制表符.在处理中被忽略.)
Ordinary characters(not %),which are expected to match the next non-white space character of the input stream.(普通字符序列,不包含%,用于匹配输入流中下面尚待读入的非空白字符序列.)
Conversion specifications,consisting of the character %,an optional assignment suppression character *,an optional number specifying a maximum field width,an optional h,l,or L indicating the width of the target,and a conversion character.(转换规格,依次由一个%,一个可选的*用于赋值屏蔽字符,一个可选的整数用于指定最大字段宽,一个可选的h,l或L用于指明转换对象的宽和一个转换字符.)
A conversion specification directs the conversion of the next input field.Normally the result is placed in the variable pointed to by the corresponding argument.
一个转换规格说明控制下一个输入字段的转换过程.通常结果保存在相应的参数所指定的变量中.
If assignment suppression is indicated by the * character,however,the input field is skipped;no assignment is made.An input field is defined as a string of non-white space characters;
如果转换规格说明中有用作屏蔽字符的*,则输入字段被跳过,不进行赋值;输入字段是非空白符组成的字符串;
it extends either to the next white space character or until the field width,if specified,is exhausted.
它的宽度要么直至下一个空白符,要么直至指定的最大字段宽.
This implies that scanf will read across line boundaries to find it input,since newlines are white space.(White space characters are blank,tab,newline,carriage return,vertical tab,and formfeed).
这表明这个sacnf将读取越过行边界读取它的输入,因为换行符也是空白符.(空白符字符是空格符,制表符,换行符,回车符,纵向制表符,和换页符).
    The conversion character indicates the interpretation of the input field.The corresponding argument must be a pointer,as required by the call-by-value semantics of C.
    转化字符用于指明如何解释输入字段.按照C语言按值调用的语义.对应的变量必须是一个指针.
conversion characters are show in Table 7-2.
转换字符列于表7-2中.

The conversion characters d,i,o,u,and x may be preceded by h to indicate that a pointer to short rather than int appears in the argument list,
转换字符d,i,o,u和x可以在前面加上h来表明其参数列表中指向short型指针而不是int类型的指针,
or by l(letter ell) to indicate that a pointer to long appears in the argument list.
或者通过l表明其参数列表中有一个指向long类型的指针.
Similarly,the conversion characters e,f,and g may be preceded by l to indicate that a pointer to double rather than float is in the argument list.
同理,转换字符e,f和g可以在前面通过l表明在参数列表中有一个指向double类型而不是float类型的指针.
    As a first example,the rudimentary calculator of Chapter 4 can be written with scanf to do the input conversion:
    做为一个例子,通过使用scanf函数进行输入转换来改写在第4章出现的具有基本元算功能的计算器程序:
#include <stdio.h>
main() /* rudimentary calculator */
{
    double sum,v;
    sum = 0;
    while(scanf("%lf",&v)==1)
        printf("\t%.2f\n",sum+=v);
    return 0;
}
    Suppose we want to read input lines that contain dates of the form
    假设我们想要读取包含数据形式的输入行
        25 Dec 1998
The scanf statement is
则相应的scanf语句为:
    int day,year;
    char monthname[20];
    sacnf(%d %s %d",&day,monthname,&year);
No & is used with monthname,since an array name is a point.
没有&用给monthname,因为数组名本身就是指针.
    Literal characters can appear in the scanf format string;they must match the same characters in the input.So we could read dates of the form mm/dd/yy with this scanf statement:
    普通字符也能够出现在scanf的格式化串中;但是它们必须与输入中相同的字符串匹配.所以我们能够通过scanf语句读取形式如mm/dd/yy的时间数据.
        int day,month,year;
        scanf("%d%d%d",&month,&day,&year);
    scanf ignores blanks and tabs in its format string.Furhtermore,it skips over white space(blank,tabs,newlines,etc.) as it looks for input values.To read input whose format is not fixed,
    scanf忽略格式化字符串中空格符和制表符.更进一步,在读取输入值时,它跳过空白符和制表符(blank,tabs,newlines,etc).为了读取固定格式的输入,
it is often best to read a line at a time,then pick it apart with sscanf.For example,suppose we want to read lines that might contain a date in either of the forms above.Then we could write
通常最好是每次读取一整行,然后通过sscanf逐个读入.例如,假设我们想要读取可能包含上述一种形式表示的日期数据的行.那么可以这样写
while(getline(line,sizeof(line)) > 0){
    if(sscanf(line,"%d %s %d",&day,monthname,&year) == 3)
        printf("valid:%s\n",line); /* 25 dec 1988 form */
    else if(sscanf(line,"%d/%d/%d",&month,&day,&year)==3)
        printf("valid:%s\n",line); /* mm/dd/yy form */
    else
        printf("invalid:%s\n",line);/* invalid form */
}
    Calls to scanf can be mixed with calls to other input functions.The next call to any input function will begin by reading the first character not read by scanf.
    scanf函数可以和其他输入函数混合起来使用.紧跟在scanf函数调用之后的下一个输入函数的调用将从scanf没有读取的第一个字符处开始读取数据.
    A final warning:the arguments to scanf and sscanf must be pointers.By far the most common error is writing
    注意:scanf和sscanf的参数必须都是指针.最常见的错误是将输入语句写成
        scanf("%d",n);
instead of 
        scanf("%d",&n);
This error is not generally detected at complie time.
编译程序在编译时一般检测不到这类错误.


Exercise 7-4. Write a private version of scanf analogous to minprintf from the previous section.

Exercise 7-5.Rewrite the postfix calculator of Chapter 4 to use scanf and/or sscanf to do the input and number conversion.


7.5 File Access
    The examples so far have all read the standard input and written the standard output,which are automatically defined for a program by the local operating system.
    到现在为止的列子都是从标准输入中读取数据并向标准输出输出数据,其中,其中标准输入和标准输出是由所用操作系统自动提供的程序访问的.
    The next step is to write a program that accesses a file that is not already connected to the program.One program that illustrates the need for such operations is cat,
    下一步是编写程序来访问文件,这个文件还没有关联程序.cat程序可说明这个问题.
which concatenates a set of named files onto the standard ouput.cat is used for printing files so the screen,
这个程序把一组文件名串联后输出到标准输出流上.cat用来打印文件到屏幕,
and as a general-purpose input collector for programs that do not have the capability of accessing files by name,For example,the command
也可以用作那些无法通过名字访问的文件的程序的通用输入收集器.例如,如下命令
        cat x.c y.c
prints the contents of the files x.c and y.c (and nothing else) on the standard output.
在标准输出流上打印文件x.c和y.c的内容(仅此而已).
    The quesion is how to arrange for the named files to be read - that is,how to connect the external names that a user thinks of to the statements that read the data.
    程序能够访问文件的关键问题是怎么样安排有名文件的读取过程- 即怎样将用户所要使用的文件的外部名和访问这些文件的语句联系起来.
    The rules are simple.Before it can be read or written,a file has to be opened by the library function fopen.fopen takes an external name like x.c or y.c,
    方法其实很简单.在读写一个文件之前,必须试用库函数fopen打开它.fopen用诸如x.c或y.c.
does some housekeeping and negotiation with the operating system(details of which needn't concern us),and returns a pointer to be used in subsequent reads or writes of the file.
这样的外部名与操作系统进行某些必要的连接和通信(细节问题不是我们关心的),并且返回一个指向读写操作的指针.
    This pointer,called the file pointer,points to a structure that contains information about the file,such as the location of a buffer,the current character position in the buffer,
    该指针叫做文件指针,它指向一个包含文件信息的结构,这额信息包括:缓冲区的位置,缓冲区中当前字符的位置,
whether the file is being read or written,and whether errors or end of file have occurred.Users don't need to know the details,    
文件是在正在读取还是正在写入,文件是否出错或是否已经达到文件的末尾等等.用户不需要知道这些细节,
because the definitions obtained from <stdio.h> include a structure declaration called FILE.The only declaration needed for a file pointer is examplified by
因为<stdio.h>中定义了一个包含了这些信息的结构FILE.程序中唯一要做的是使用声明如下:
        FILE *fp;
        FILE *fopen(char *name,char *mode);
This says that fp is a pointer to a FILE,and fopen returns a pointer to a FILE.Notice that FILE is a type name,like int,not a structure tag;it is defined with a typedef.
这里说明指针fp是一个指向文件的指针,而fopen函数返回的也是一个指向结构FILE的指针.注意FILE是类型名,像int一样,而不是结构标记;它由typedef定义.
(Details of how fopen can be implemented on the UNIX system are given in Setion 8.5.)
(关于fopen在UNIX系统的实现细节将在第8.5节讨论)
    The call to fopen in a program is 
    在程序中调用fopen如下
        fp = fopen(name,mode);
The first argument of fopen is a character string containing the name of the file.The second argument is the mode,also a character string,which indicates how one intends to use the file.
fopen的第一个参数是包含文件的名称的字符串.第二个参数是读写模式,同样是字符串,用来指示用户使用文件的方式.
Allowable modes include read ("r"),write("w"),and append ("a").Some systems distinguish between text and binary files;for the latter,a "b" must be appended to the mode string.
被允许的模式包括读("r"),写("w"),和追加("a").一些系统还区分文本和二进制文件;后则需要在方式中添加"b"字符.
    If a file that does not exist is opened for writing or appending,it is created if possible.Opening an existing file for writing causes the old contents to be discarded,
    如果以写或追加的方式打开一个不存在的文件,那么系统将创建所指名的文件.以写方式打开一个已存在的文件,该文件原来的内容将被替换,
while opening for appending preserves them.Trying to read a file that does not exist is an error,and there may be other causes of error as well,like trying to read a file when you don't have permission.
而如果是以追加方式打开文件,则文件原来的内容保持不变.尝试读取一个文件而这个文件不存在则会出现错误,其他一些问题也可能导致错误发生,像尝试读取一个文件当你没有其权限时.
If there is any error,fopen will return NULL.(The error can be identified more precisely;see the discussion of error-handling functions at the end of Section 1 in Appendix B.)
如果发生任何错误,fopen将会返回NULL.(错误能够指示更精确;查看讨论关于错误处理函数在附录B.1节中.)
    The next thing needed is a way to read or write the file once it is open.There are several possibilities,of which getc and putc are the simplest.getc returns the next character from a file;
    一旦文件被打开,下面要做的就是读写文件了.这里有几种方法操作,其中getc和putc都是最简单的.getc从文件中返回下一个字符;
it needs the file pointer to tell it which file.
它需要一个文件指针告诉它哪个文件进行操作.
        int getc(FILE *fp);
getc returns the next character form the stream referred to by fp;it returns EOF for end of file or error.
getc返回fp指向的输入流中的下一个字符;如果到达文件末尾或出现错误,它返回EOF.
    putc is an output function:
    putc是输出函数:
        int putc(int c,FILE *fp);
putc writes the character c to the file fp and returns the character written,or EOF if an error occurs.Like getchar and putchar,getc and putc may be macros instead of functions.
putc函数将字符c写入文件fp指向的并且返回所写入的字符,如果错误发生时,则返回EOF.像getchar和putchar函数一样,getc和putc可以作为宏.
    When a C program is started,the operating system environment is responsible for opening three files and providing file pointers for them.These files are the standard input,the standard output,
    当C程序启动时,操作系统环境负责提供打三个文件并为它们提供相应的指针.这些文件都是标准输入,标准输出,
and the standard error;the corresponding file pointers are called stdin,stdout,and stderr,and are declared in <stdio.h>. 
和标准错误;其相应的指针分别叫做stdin,stdout,和stderr,他们都定义在<stdio.h>中.
Normally stdin is connected to the keyboard and stdout and stderr are connected to the screen,but stdin and stdout may be redirected to files or pipes as described in Section 7.1.
在大多数环境中,stdin连接到键盘,而stout和stderr连接到显示器,正如在7.1节有过描述,stdin和stdout能够重定向到文件或管道.
    getchar and putchar can be defined in terms of getc,putc,stdin,and stdout as follows:
    getchar和putchar函数可以用getc,putc,stdin和stdout函数定义如下:
        #define getchar()      getc(stdin)
        #define putchar(c)    putc((c),stdout)
    For formatted input or output of files,the functions fscanf and fprintf may be used.These are identical to scanf and printf,
    为了格式化输入或输出文件,可以使用函数fscanf和fprintf.它们与scanf和printf函数的区别仅仅在于
except that the first argument is a file pointer that specifies the file to be read or written;the format string is the second argument.
它们的第一个参数是文件指针,这个文件指针指向所要读写的文件;第二个参数是格式化字符串.
        int fscanf(FILE *fp,char *format,...)
        int fprintf(FILE *fp,char *format,...)
    With these preliminaries out of the way,we are now in a position to write the program cat to concatenate files.The design is one that has been found convenient for many programs,
    在掌握这些初步的方式之后,我们现在就能够编写将文件串联的cat程序了.该程序的设计过程和其他许多程序的设计过程类似,
If there are command-line arguments,they are interpreted as filenames,and processed in order.If there are no arguments,the standard input is processed.
如果命令行中带有参数,则将它们作为文件名并且按次序处理.如果没有参数,则按标准输入处理.
#include <stdio.h>

void filecopy(FILE *ifp,FILE *ofp);

/* cat:concatenate files,version 1 */
main(int argc,char *argv[])
{
	FILE *fp;
	void filecopy(FILE *,FILE *);
	if(argc == 1) /* no args;copy standard input */
		filecopy(stdin,stdout);
	else{
		while(--argc>0){
			if((fp = fopen(*++argv,"r"))==NULL){
				printf("cat:can't open %s\n",*argv);
				return 1;
			}
			else{
				filecopy(fp,stdout);
				fclose(fp);
			}			
		}		
	}
	return 0;
}

/* filecopy:copy file ifp to file ofp */
void filecopy(FILE *ifp,FILE *ofp)
{
	int c;
	while((c=getc(ifp))!=EOF)
		putc(c,ofp);
}

The file pointers stdin and stdout are objects of type FILE *.They are constants,however,not variables,so it is not possible to assign to them.
文件指针stdin和stdout都是对象,其类型为FILE*,它们都是常量而不是变量,所以不能够对其赋值.
    The function
        int fclose(FILE *fp);
is the inverse of fopen;it breaks the connection between the file pointer and the external name that was established by fopen,freeing the file pointer for another file.
执行和fopen相反的操作;它断开由fopen函数建立的两个文件指针和其外部名称之间的连接,释放文件指针已给其他文件使用.
Since most operating systems have some limit on the number of files that a program may have open simultaneously,it's a good idea to free file pointers when they are no longer needed,
因为大多数操作系统都限制了一个程序所能打开的文件数量.所以当文件指针不再需要时就释放它是一个好的编程思想,
as we did in cat.There is also another reason for fclose on an putput file - it flushes the buffer in which putc is collecting ouput.
就像我们在cat中所做的一样.在输出文件上使用fclose函数还有另外一个原因 - 它将缓冲区中有put函数正在收集的输出写到文件中.
fclose is called automatically for each open file when a program terminates normally.
当一个程序正常终止时,程序自动为每个打开的文件调用fclose函数.
(You can close stdin and stdout if they are not needed.They can also be reassigned by the library function freopen.)
(如果不再需要stdin和stdout你可以把它们关闭.它们也能通过freopen函数重新赋值.)


7.6 Error Handling - Stderr and Exit
    The treatment of error in cat is not ideal.The trouble is that if one of the files can't be accessed for some reason,the diagnostic is printed at the end of the concatenated output.
    cat程序的错误处理部分并不完善.问题在于如果由于某种原因而造成其中一个文件不能被访问时,相应的诊断信息被打印到输出的末尾.
That might be acceptable if the output is going to a screen,but not if it's going into a file or into another program via a pipeline.
当该输出指向屏幕时这种处理尚可接受,但如果它指向一个文件或借助于管道而指向另一个程序的输入时则会出问题.
    To handle this situation better,a second output stream,called stderr,is assigned to a program in the same way that stdin and stdout are.
    为了处理这种情况,操作系统像提供stdin和stdout一样自动提供了另一个称为stderr的输出流.
Output written on stderr normally appears on the screen even if the standard output is redirected.
即使使用了重定向输出,stderr上的输出通常也会显示在屏幕上.
    Let us revise cat to write its error messages on the standard error.
    下面改写cat程序来写错误信息在标准错误上.

#include <stdio.h>

void filecopy(FILE *ifp,FILE *ofp);

/* cat: concatenate files,version 2 */
main(int argc,char *argv[])
{
	FILE *fp;
	void filecopy(FILE *,FILE *);
	char *prog = argv[0]; /* program name for error */
	if(argc == 1) /* no args; copy standard input */
		filecopy(stdin,stdout);
	else
		while(--argc>0){
			if((fp = fopen(*++argv,"r")) == NULL){
				fprintf(stderr,"%s:can't open %s\n",prog,*argv);
				exit(1);
			}else{
				filecopy(fp,stdout);
				fclose(fp);
			}			
		}
	if(ferror(stdout)){
		fprintf(stderr,"%s:error writing stdout\n",prog);
	}
	exit(0);
}

/* filecopy:copy file ifp to file ofp */
void filecopy(FILE *ifp,FILE *ofp)
{
	int c;
	while((c=getc(ifp))!=EOF)
		putc(c,ofp);
}
    The program signals errors two ways.First,the diagnostic output produced by fprintf goes onto stderr,so it finds its way to the screen instead of disappearing down a pipelien or into an output file.
    该程序通过两种方式报错,第一种,由fprintf产生的诊断信息输出到stderr上,因此诊断信息将会显示在屏幕上而不是消失在管道或一个输出文件上.
We included the program name,from argv[0],in the message,so if this program is used with others,the source of an error is identified.
诊断消息中包含argv[0]中的程序名,所以如果程序被用来和其他程序一起使用,可以识别错误的来源.
    Scond,The program uses the standard library function exit,which terminates program execution when it is called.The argument of exit is available to whatever process called this one,
    第二,程序使用标准的库函数exit,当它被调用时将终止调用程序的执行.任何调用exit的进程都可以得到它的变量.
so the success or failure of the program can be tested by another program that uses this one as a sub-process.Conventionally,a return value of 0 signals that all is well;
因此可通过另外一个将该程序作为子进程的程序来测试该程序是否成功的执行了.按惯例,0返回值表示一切正常;
non-zero values usually signal abnormal situations.exit calls fclose for each open output file,to flush out any buffered output.
非0的值通常表示出现了异常.exit为每个已经打开的输出文件调用相应的fclose函数,将任何已缓存的输出写到相应文件中.
    Within main,return expr is equivalent to exit(expr).exit has the advantage that it can be called from other functions,and that calls to it can be found with a pattern-searching program like those in Chapter 5.
    在主程序中,返回expr等价于exit(expr).exit有如下优点,它能够被其他函数调用,并且可以用诸如第五章中所描述的模式查找函数查找这些调用.
    The function ferror returns non-zero if an error occurred on the stream fp.
    如果流fp上发生错误,则函数ferror返回非0值.
        int ferror(FILE *fp);
Although output errors are rare,they do occur(for example,if a disk fills up),so a production program should check this as well.
尽管输出错误我们很少碰到,但是它确实存在(例如,磁盘满了),所以商业程序也应该能检查这个错误.
    The function feof(FILE *) is analogous to ferror;it returns non-zero if end of file has occurred on the specified file.
    函数feof(FILE *)与ferror类似;它返回非0的值如果文件结尾发生错误.
        int feof(FILE *fp);
    We have generally not worried about exit status in our small illustrative programs,but any serious program should take care to return sensible,useful status values.
    上面讨论的这个旨在说明问题的小程序中,不用担心出口返回的状态,但重要的程序都应该小心检查返回合理且有意义的数值. 



7.7 Line Input and Output
    The standard library provides an input routine fgets that is similar to the getline function that we have used in earlier chapters:
    标准库函数提供一个输入函数fgets,它和前面几章使用过的getline函数相似:
        char *fgets(char *line,int maxline,FILE *fp);
fgets reads the next input line(include the newline) from file fp into the character array line;at  most maxline-1 characters will be read.The resulting line is terminated with '\0'.Normally fgets returns line;
fgets读取下一行输入(包括换行符)从文件fp中存入到字符数组line中;最多可读取maxline-1个字符.读取的结果'\0'结尾.通常fgets返回line,
on end of file or error it return NULL.(Our getline returns the line length,which is a more useful value;zero means end of file.)
在文件结尾或错误时它返回NULL.(我们的getline返回line的长度,一个更有用的值;0意味着文件结尾.)
    For output,the function fputs writes a string(which need not contain a newline) to a file:
    对于输出,函数fputs将一个字符串(不必包含换行符)写入一个文件中:
        int fputs(char *line,FILE *fp);
It returns EOF if an error occurs,and non-negative otherwise.
当有错误出现时它返回EOF,否则返回0.
    The library functions gets and puts are similar to fgets and fputs,but operate on stdin and stdout.Confusingly,gets deletes the terminal '\n',and puts adds it.
    库函数gets和puts类似于fgets和fputs,但他们在在stdin和stdout上操作.不同的是,gets函数在读取字符串时将删除结尾的换行符'\n',而puts函数在所写出的字符串后还要增加换行符.
    To show that there is nothing special about functions like fgets and fputs,here they are,copied from the standard library on our system:
    为了展示诸如fgets和fputs这样的函数没什么特别的地方,我们将标准库中的代码复制如下:
/* fgets: get at most n-1 chars,plus a null from iop */
char *fgets(char *s,int n,FILE *iop)
{
	register int c;
	register char *cs;
	cs = s;
	while(--n>0 && (c=getc(iop))!=EOF){
		if((*cs++=c)=='\n')
			break;
	}
	*cs = '\0';
	return (c==EOF && cs==s)?NULL:s;	
}

/* fputs:put string s on file iop */
int fputs(char *s,FILE *iop)
{
	int c;
	while(c==*s++)
		putc(c,iop);
	return ferror(iop)?EOF:non-negative;
}
The standard specifies that ferror return non-zero for error;fputs returns EOF for error and a non-negative value otherwise.
标准规定,ferror函数在遇到错误时返回非0值;而fputs函数在遇到错误时则返回EOF.否则返回一个非负整数值.
    It is easy to implement our getline from fgets:
    用fgets函数很容易实现getline函数:
    /* getline:read a line,return length */
    int getline(char *lien,int max)
    {
        if(fgets(line,max,stdin)==NULL)
            return 0;
        else
            return strlen(line);
        }

Exercise 7-6. Write a program to compare two files,printing the first line where they differ.

Exercise 7-7.Modify the pattern finding program of Chapter 5 to take its input from a set of named files or,if no files are named as arguments,from the standard input.Should the file name be printed when a matching line is found?

Exercise 7-8.Write a program to print a set of files,starting each new one on a new page,with a title and a running page count for each file.

