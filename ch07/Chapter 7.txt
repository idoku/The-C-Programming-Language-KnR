CHAPTER 7 Input and Output
    Input and output facilities are not part of the C language iteslf,so we have not emphasized them in our presentation thus far.Nonetheless,
    输入和输出功能并不是C语言本身的组成部分,所以到目前为止,我们并没有过多的强调它们.然而,
parograms interact with thier environment in much more complicated ways than whose we have shown before.In this chapter we will describe the standard libary,
程序与其环境之间的交互与我们之前所展示的相比复杂了许多.本章我们将描述标准库,
a set of functions that provide input and output,string handling,storage management,mathematical routines,and a variety of other services for C programs.We will concentrate on input and output.
一些函数,提供输入,输出和字符串处理,存储管理,数学函数,和一些其他的功能用于C程序.我们将着重讨论输入和输出.
    The ANSI standard defines these library functions precisely,so that they can exist in compatible form on any system where C exists.
    标准的ANSI定义了这些库函数,所以这些函数在任何使用C语言的系统中都能以相容的形式存在.
Programs that confine their system interactions to facilities provided by the standard library can be moved from one system to another without change.
程序系统交互部分仅仅使用了由标准库提供的功能,那么在系统移植到另一个系统时,不需要修改.
    The properties of library functions are specified in more than a dozen headers;we have already seen several of these,including <stdio.h>,<stirng.h>,and <ctype.h>.
    标准库函数的性质分别定义在十几个头文件中;我们之前已经碰到一些,它们是,<stdio.h>,<string.h>和<ctype.h>.
We will not present the entire library here,since we are more interested in writing C programs that use it.The library is described in detail in Appendix B.
我们不会罗列整个标准库在这里,我们更感兴趣是编写C程序来使用它们.附录B对标准库做了详细的描述.

7.1 Standard Input and Output
    As we said in Chapter 1,the library implements a simple model of text input newline character.A text stream consists of a sequence of lines;each line ends with a newline character.
    正如第一章所述,标准库实现了简单的文本输入输出模式.文本流由一些行组成,每一行的结尾是一个换行符.
If the system doesn't operate that way,the library does whatever is necessary to make it appear as if it does.For instance,
如果系统不是这种方式操作,标准库尽可能使该系统适用这种模式.例如,
the library might convert carriage return and linefeed to newline on input and back again on output.
标准库可以在输入端将回车和换行符都转换为换行符,而在输出端反向转换.
    The simplest input mechanism is to read one character at a time from the standard input,normally the keyboard,with getchar:
    最简单的输入机制是读取一个字符每次从标准输入,一般为键盘,通过getchar函数:
        int getchar(void)
getchar returns the next input character each time it is called,or EOF when it encounters end of file.The symbolic constant EOF is defined in <stido.h>.The value is typically -1,
getchar在每次被调用时返回下一个字符,或者EOF当统计到文件末尾.符号常量EOF被定义在<stdio.h>.其值一般为-1.
but tests should be written in terms of EOF so as to be independent of the specific value.
但是程序中应该使用EOF而不是-1来测试文件是否结束,以使得程序独立于EOF的特定值.
    In many environments,a file may be substituted for the keyboard by using the < convention for input redirection:if a program prog uses getchar,then the command line 
    在许多环境中,通过使用符号<让一个文件代替键盘来实现输入重定向:如果程序prog中要使用函数getchar,那么命令行
        prog < infile
causes prog to read characters from infile instead.The swithcing of the input is done in such a way that prog itself is oblivious to the change;in particular,
使得程序prog从文件而不是从键盘中读取字符.实际上,输入开关的实现对程序prog本身是透明的,
the string "< infile" is not included in argv.Input switching is also invsible if the input comes from another program vai a pipe mechanism:on some systems,the command line
字符串"<inflie"也没有包含在argv的命令变量中.如果输入通过管道机制来自另一个程序,那么这种输入开关也是不可见的:在一些系统中,命令行
        otherprog | prog
runs the two programs otherprog and prog,and pipes the standard output of otherprog into the standard input for prog.
将运行两个程序otherprog和prog,而且将程序otherprog的标准输出流连接到程序prog的标准流上.
    The function
        int putchar(int)
is used for output:putchar(c) puts the character c on the standard output,which is by default the screen.putchar returns the character writeen,or EOF if an error occurs.Again,
用于输出:putchar(c)输出字符c在标准输出上,这个标准输出默认是屏幕显示.如果没有错误,putchar返回所有字符,如果出现错误则返回EOF.同理,
output can usually be directed to a file with > filename;if prog uses putchar.
output能够使用>文件名直接重定向输出到某个文件;如果prog使用putchar输出文件.
    prog > outfile
will write the standard output to outfile instead.If pipes are supported,
将输出标准输出的数据到文件outfile中.如果管道被系统支持,那么命令行
    prog | anotherprog
puts the standard output of prog into the standard input of antoherprog.
将程序prog的标准输出流连接到程序anotherprog的标准输出上.
    Output produced by printf also finds its way to the standard output,Calls to putchar and printf may be interleaved - output appears in the order in which the calls were made.
    函数printf也能够用于向标准输出流输出数据,我们在程序中有可能要交叉调用putchar和printf - 输出将按照函数调用的先后次序产生.
    Each source file that refers to an input/output library function must contain the line
    每一个使用输入/输出标准库函数的源程序文件必须在引用这些函数之前包含如下语句
        #include <stdio.h>
before the first reference.When the name is bracketed by < and > a search is made for the header in a stnadard set of places(for example,on UNXI systems,typically in the directory /user/include).
当文件名用一对尖括号<和>括起来时,预处理程序在实现定义的有关位置中查找所指明的文件(例如,在UNXI系统中,通常是在目录/user/include中).
    Many programs read only one input stream and write only one output stream;for such program,input and ouput with getchar,putchar,and printf may be entirely adequate,
    许多程序只从一个输入流读取数据并且仅仅写入一个输出流输出数据;对于这些程序,输入和输出值只需要getchar,putchar和printf来实现输出即可,
and is certainly enough to get started.This is particularly true if redirection is used to connect the output of one program to the input of the next.For example,consider the program lower,
并且能够保证正常启动.尤其是在重定向将一个程序的输出给另一个程序输入的情况下.例如,考虑下面的程序lower,
which converts its input to lower case:
这个程序转换输入的小写字母的形式:
    #include <stdio.h>
    #include <ctype.h>
    main() /* lower:convert input to lower case */
    {
        int c;
        while((c=getchar())!=EOF)
            putchar(tolower(c));
        return 0;
    }
    The function tolower is defined in <ctype.h>;it converts an upper case letter to lower case,and returns other characters untouched.As we mentioned earlier,
    函数tolower定义在<ctype.h>中;它转换一个大写字母为小写形式,并且原样返回其他字符.在我们之前提到的,
"functions" like getchar and putchar in <stdio.h> and tolower in <ctype.h> are often macros,thus avoiding the overhead of a function call per character.
诸如头文件<stdio.h>中的getchar和putchar函数以及<ctype.h>中的tolower"函数"一般都为宏,从而避免了对每个字符都进行函数调用的开销.
We will show how this is done in Secton 8.5.Regardless of how the <ctype.h> functions are implemented on a given machine,programs that use them are shielded from knowledge of the character set.
我们将在8.5节介绍其实现方法.无论<ctype.h>中的函数在给定的机器上是如何实现的,使用这些程序都可以不必了解字符集的知识.

Exercise 7-1.Write a program that converts upper case to lower or lower case to upper,depending on the name it is invoked with,as found in argv[0[.



7.2 Formatted Output - Printf
    The output function printf translates internal values to character.We have used printf informally in previous chapters.The description here convers most typical uses but is not complete;
    输出函数printf用于将内部数值转换为字符.在前面的章节中,我们已经非正式的使用过printf函数.下面的描述包含了最常用的典型用法,但是不是全部的;
for the full story,see Appendix B.
在附录B中给出了完整的使用方法.
        int printf(char *format,arg1,arg2,...)
printf converts,formats,and prints its arguments on the standard output under control of the format.It returns the number of characters printed.
printf函数在输出格式format的控制下,将其参数转换,格式化并在标准输出设备上打印出来.它的返回值为打印的字符数.
    The format string contains two types of object:ordinary characters,which are copied to the output stream,
    格式化字符串包含两个类型的对象:普通字符,将其值拷贝到输出流中.
and conversion specifications,each of which causes conversion and printing of the next successive argument to printf.
和转换规格说明,转换规格说明不拷贝到输出流中,每个说明控制printf中参数的转换和打印
Each conversion specification begins with a % and ends with a conversion character.Between the % and the conversion character there may be,in order:
每一个转换说明都由%引入,并且以一个转换字符结束.在%和转换字符之间可能有如下成分:
A minus sign,which specifies left adjustment of the converted argument.(负号,指定转换参数按照左对齐的形式输出.)
A number that specifies the minimum field width.The converted argument will be printed in a field at least this wide.If necessary it will be padded on the left(or right,if left adjustment is called for) to make up the field width.(数,指定最小字宽.被转换的参数将在不小于最小字段宽的宽度中打印出来.如果必要,字段左面(或右面,如果使用左对齐)多余的字符位置用空格填充以保证最小字段宽)
A period,which separates the field width from the precision.(小数点,用于将字段宽和精度分开.)
A number,the precision,that specifies the maximum number of characters to be printed from a string,or the number of digits after the decimal point of a floating point value,or the minimum number of digits for an integer.(数,精度,指定一个字符所要打印的最大字符数,或者一个浮点数小数点的位置,或一个整数最少输出的数字数目.)
An h if the integer is to be printed as a short,or l (letter ell) if as a long.(字母h或l,字母h表示将整数按short类型打印,字母l表示将整数作为long类型打印.)
Conversion characters are show in Table 7-1.If the character after the % is not a conversion specification,the behavior is underfined.
表7-1列出了所有转换字符.如果%后面的字符不是一个转换规格说明字符,则该行为是未定义的.
Table 7-1.BASIC PRINTF CONVERSIONS


A width or precision may be specified as *,in which case the value is computed by converting the next argument(which must be an int).For example,to print at most max characters from a string s,
在转换规格说明中,一个宽度或者精度可能用*代替,这时,宽度和精度的值通过转换下一个变量（必须为int型)来计算.例如,为了从字符串s中最多打印max个字符,
        printf("%.*s",max,s);
    Most of the format conversions have been illustrated in earlier chapters.One exception is precsion as it relates to strings.
    在前面的章节描述了大多数的格式化转换.但还未介绍与字符串相关的精度.
The following table shows the effect of a variety of specifications in printing "hello,wold"(12 characters).We have put colons around each field so you can see its extent.
下面的表中展示了打印字符串"hello,world"(12个字符),我们在每个字段的两边加上冒号,这样能更清楚的看到宽度.
:%s:             :hello, world:
:%10s:         :hello, world:
:%.10s:        :hello, wor:
:%-10s:        :hello, world:
:%.15s:        :hello, world:
:%-15s:        :hello, world     :
:%15.10s:     :     hello, wor:
:%-15.10s:    :hello, wor     :
A warning:printf uses its first argument to decide how many arguments follow and what their types are.
注意:printf使用它的第一个参数来判断还有多少参数和它们的类型是什么.
It will get confused,and you will get wrong answers,if there are not enough arguments or if they are the wrong type.You should also be aware of the difference between these two calls:
如果printf从第二个参数起的参数少于第一个参数中指定的个数或它们的类型与第一个参数中指定的类型不同时,那么会得到错误的记过.请注意下面两个调用之间的不同:
        printf(s);        /* FAILS if a contains % */
        printf("%s",s) /* SAFE */
    The function sprintf does the same conversions as printf does,but stores the output in a string:
    函数sprinitf做同样的转换和printf所做一样,但是它把输出存在一个字符串中.
        int sprintf(char *string,char *format,arg1,arg2,...)
sprintf formats the arguments in arg1,arg2,etc.,according to format as before,but places the result in string instead of on the standard output;string must be big enougth to recevice the result.
sprintf函数和之前printf函数一样,按照fortmat格式化参数序列,如arg1,arg2,等.但是它将结果存放在string而不是放在标准输出中;当然string必须足够大来接收结果.

Exercise 7-2. Write a program that will print arbitrary input in a sensible way.As a minimum,it shoud print non-graphic characters in octal or hexadecimal according to local custom,and break long text lines.


7.3 Variable-length Argument Lists
    This section contains an implementation of a minimal version of printf,to show how to write a function that processes a variable-length argument list in a portable way.
    本节包含一个简单版本的printf,来演示怎样编写一个处理可变长度的参数的函数.
Since we are mainly interested in the argument processing,minprintf will process the format string and arguments but will call the real printf to do the format cnoversions.
因为重点在参数的处理,minprintf将处理格式化字符串和参数表,格式化转换则通过调用函数printf来实现.
    The proper declaration for printf is 
    下面是printf的正确声明方式
        int printf(char *fmt,..)
where the declaration ... means that the number and types of these arguments may vary.The declaration ... can only appear at the end of an argument list.Our minprintf is declared as
其中,省略号声明...代表参数表中参数的数量和类型可能会变化.省略号声明...只能出现在参数表的结尾处.我们的minprintf声明如下:
        void minprintf(char *fmt,...) 
since we will not return the character count that printf does.
因为我们的minprintf不像printf那样返回实际输出的字符数.
    The tricky bit is how minprintf walks along the argument list when the list doesn't even have a name.
    编写minprintf的关键点在与怎么样处理甚至连名字都没有的变量列表.
This standard header <stdarg.h> contains a set of macro definitions that define how to step through an argument list.
这个标准头文件在<stdarg.h>中包含一组如何处理变量表的宏定义.
The implementation of this header will vary from machine to machine,but the interface it presents is uniform.
这个头文件的实现随着机器不同而不同,但是它所提供的接口是统一的.
    The type va_list is used to declare a variable that will refer to each argument in turn;in minprintf,this variable is called ap,for "argument pointer." 
    类型va_list用来声明一个依次引用每个变量的变量,在minprintf,这个变量叫做ap,表示"argument pointer."
The macro va_start initializes ap to point to the first unnamed argument.It must be called once before ap is used.There must be at least one named argument;
而宏va_start初始化ap指针指向第一个无名变量.在ap使用之前,这个宏必须被调用一次.变量表中必须有至少一个命令变量;
the final named argument is used by va_start to get started.
va_start根据最后一个命名变量的值来对ap进行初始化.
    Each call of va_arg returns one argument and steps ap to the next;va_arg uses a type name to determine what type to return and how big a step to take.
    每一次调用va_arg返回一个变量并且使ap指向下一个变量;va_arg使用一个类型名决定其返回哪种类型的对象及如何使ap指向下一个变量.
Finally,va_end does whatever cleanup is neccessary.It must be called before the function returns.
最终,va_end必须在函数返回之前被调用,完成一些必要的清除工作.
    There properties from the basis of our simplified printf:
    上面是一些属性,我们简单的printf的基础讨论:
#include <stdarg.h>

/* minprintf:minial printf with variable argument list */
void minprintf(char *fmt,...)
{
	va_list ap;/* points to each unnamed arg in turn */
	char *p,*sval;
	int ival;
	double dval;
	va_start(ap,fmt); /* make ap point to 1st unnamed arg */
	for(p = fmt;*p;p++)
	{
		if(*p!='%'){
			putchar(*p);
			continue;
		}
		switch(*++p)
		{
			case 'd':
				ival = va_arg(ap,int);
				printf("%d",ival);
				break;
			case 'f':
				dval = va_arg(ap,double);
				printf("%f",dval);
				break;
			case 's':
				for(sval=va_arg(ap,char *);*sval;sval++)
				{
					putchar(*sval);
				}
				break;
			default:
				putchar(*p);
				break;
		}
	}
	va_end(ap); /* clean up when done */
}

Exercise 7-3. Revise minprintf to handle more of the other facilities of printf.



7.4 Formatted Input - Scanf
    The fnction scanf is the input analog of printf,providing many of the same conversion facilities in the opposite direction.
    输入函数scanf对应于输出函数printf,它在与后者反向上提供同样多的转换功能.
        int scanf(char *format,...)
scanf reads characters from the standard input,interprets them according to the specification in format,and stores the results through the remaining arguments.
scanf函数从标准的输入中读取字符,按照format中的转换规格说明对字符序列进行解释,并把结果存储在其余的变量中.
The format argument is described below;the other arguments,each of which must be a pointer,indicate where the corresponding converted input should be stored.
下面将讨论格式化变量format;其他变量必须是一个指针,用于指明相对应的转换后的输入应该存放的位置.
As with printf,this section is a summary of the most useful features,not an exhaustive list.
像printf一样,本节介绍大多数有用的特性,但不是全部的功能列表.
    scanf stops when it exhausts its format string,or when some input fails to match the control specification.It returns as its value the number of success items were found.
    当scanf函数使用完了格式输入串或当一些输入无法与控制说明相匹配时,它就停止运行.并返回成功匹配和赋值的输入项的个数.
This can be used to decide how many items were found.On end of file,EOF is returned;note that this is different from 0,
所以返回值可以作为判断已获得输入值的输入项的依据.在文件末尾,EOF被返回;注意这与返回值0不同.
which means that the next input character does not match the first specification in the format string.The next call to scanf resumes searching immediately after the last character alredy converted.
0意味着下一个输入字符没有匹配第一个说明符.下一次对这个函数的调用将从上一次成功转换的最后一个字符的下一个字符开始继续搜索.
    There is also a function sscanf that reads from a string instead of the standard input:
    另外一个输入函数sscanf,用于从一个字符串而不是标准输入流中读取字符序列:
        int sscanf(char *string,char *format,arg1,arg2,...)
It scans the string according to the format in format,and stores the resulting values through arg1,arg2,etc.These arguments must be pointers.
它按照格式变量format中说明的格式从字符串string中读取字符序列,并且把结果存储在arg1,arg2等这些变量中.这些参数必须是指针.
    The format string usually contains conversion specifications,which are used to control conversion of input.The format string may contain:
    格式化字符串通常包含转换规格说明,其用来控制输入转换.格式化字符串通常包含:
Blanks or tabs,which are ignored.(空格或制表符.在处理中被忽略.)
Ordinary characters(not %),which are expected to match the next non-white space character of the input stream.(普通字符序列,不包含%,用于匹配输入流中下面尚待读入的非空白字符序列.)
Conversion specifications,consisting of the character %,an optional assignment suppression character *,an optional number specifying a maximum field width,an optional h,l,or L indicating the width of the target,and a conversion character.(转换规格,依次由一个%,一个可选的*用于赋值屏蔽字符,一个可选的整数用于指定最大字段宽,一个可选的h,l或L用于指明转换对象的宽和一个转换字符.)
A conversion specification directs the conversion of the next input field.Normally the result is placed in the variable pointed to by the corresponding argument.
一个转换规格说明控制下一个输入字段的转换过程.通常结果保存在相应的参数所指定的变量中.
If assignment suppression is indicated by the * character,however,the input field is skipped;no assignment is made.An input field is defined as a string of non-white space characters;
如果转换规格说明中有用作屏蔽字符的*,则输入字段被跳过,不进行赋值;输入字段是非空白符组成的字符串;
it extends either to the next white space character or until the field width,if specified,is exhausted.
它的宽度要么直至下一个空白符,要么直至指定的最大字段宽.
This implies that scanf will read across line boundaries to find it input,since newlines are white space.(White space characters are blank,tab,newline,carriage return,vertical tab,and formfeed).
这表明这个sacnf将读取越过行边界读取它的输入,因为换行符也是空白符.(空白符字符是空格符,制表符,换行符,回车符,纵向制表符,和换页符).
    The conversion character indicates the interpretation of the input field.The corresponding argument must be a pointer,as required by the call-by-value semantics of C.
    转化字符用于指明如何解释输入字段.按照C语言按值调用的语义.对应的变量必须是一个指针.
conversion characters are show in Table 7-2.
转换字符列于表7-2中.

The conversion characters d,i,o,u,and x may be preceded by h to indicate that a pointer to short rather than int appears in the argument list,
转换字符d,i,o,u和x可以在前面加上h来表明其参数列表中指向short型指针而不是int类型的指针,
or by l(letter ell) to indicate that a pointer to long appears in the argument list.
或者通过l表明其参数列表中有一个指向long类型的指针.
Similarly,the conversion characters e,f,and g may be preceded by l to indicate that a pointer to double rather than float is in the argument list.
同理,转换字符e,f和g可以在前面通过l表明在参数列表中有一个指向double类型而不是float类型的指针.
    As a first example,the rudimentary calculator of Chapter 4 can be written with scanf to do the input conversion:
    做为一个例子,通过使用scanf函数进行输入转换来改写在第4章出现的具有基本元算功能的计算器程序:
#include <stdio.h>
main() /* rudimentary calculator */
{
    double sum,v;
    sum = 0;
    while(scanf("%lf",&v)==1)
        printf("\t%.2f\n",sum+=v);
    return 0;
}
    Suppose we want to read input lines that contain dates of the form
    假设我们想要读取包含数据形式的输入行
        25 Dec 1998
The scanf statement is
则相应的scanf语句为:
    int day,year;
    char monthname[20];
    sacnf(%d %s %d",&day,monthname,&year);
No & is used with monthname,since an array name is a point.
没有&用给monthname,因为数组名本身就是指针.
    Literal characters can appear in the scanf format string;they must match the same characters in the input.So we could read dates of the form mm/dd/yy with this scanf statement:
    普通字符也能够出现在scanf的格式化串中;但是它们必须与输入中相同的字符串匹配.所以我们能够通过scanf语句读取形式如mm/dd/yy的时间数据.
        int day,month,year;
        scanf("%d%d%d",&month,&day,&year);
    scanf ignores blanks and tabs in its format string.Furhtermore,it skips over white space(blank,tabs,newlines,etc.) as it looks for input values.To read input whose format is not fixed,
    scanf忽略格式化字符串中空格符和制表符.更进一步,在读取输入值时,它跳过空白符和制表符(blank,tabs,newlines,etc).为了读取固定格式的输入,
it is often best to read a line at a time,then pick it apart with sscanf.For example,suppose we want to read lines that might contain a date in either of the forms above.Then we could write
通常最好是每次读取一整行,然后通过sscanf逐个读入.例如,假设我们想要读取可能包含上述一种形式表示的日期数据的行.那么可以这样写
while(getline(line,sizeof(line)) > 0){
    if(sscanf(line,"%d %s %d",&day,monthname,&year) == 3)
        printf("valid:%s\n",line); /* 25 dec 1988 form */
    else if(sscanf(line,"%d/%d/%d",&month,&day,&year)==3)
        printf("valid:%s\n",line); /* mm/dd/yy form */
    else
        printf("invalid:%s\n",line);/* invalid form */
}
    Calls to scanf can be mixed with calls to other input functions.The next call to any input function will begin by reading the first character not read by scanf.
    scanf函数可以和其他输入函数混合起来使用.紧跟在scanf函数调用之后的下一个输入函数的调用将从scanf没有读取的第一个字符处开始读取数据.
    A final warning:the arguments to scanf and sscanf must be pointers.By far the most common error is writing
    注意:scanf和sscanf的参数必须都是指针.最常见的错误是将输入语句写成
        scanf("%d",n);
instead of 
        scanf("%d",&n);
This error is not generally detected at complie time.
编译程序在编译时一般检测不到这类错误.

